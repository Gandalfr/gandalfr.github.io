<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>EventBus 使用建议</title>
      <link href="/2020/05/30/EventBus-%E4%BD%BF%E7%94%A8%E5%BB%BA%E8%AE%AE/"/>
      <url>/2020/05/30/EventBus-%E4%BD%BF%E7%94%A8%E5%BB%BA%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<p>之前项目在做组件化的调整，组件间的通信是用的类似Event Bus的订阅-发布方式进行的，在多线程的情况下没有好好处理，因此学习一些Event Bus的处理方式，这里先翻译了一篇EventBus的使用建议。</p><a id="more"></a><p>内容主要翻译于:<a href="https://www.techyourchance.com/event-bus/" target="_blank" rel="noopener">Event Bus: Pros, Cons and Best Practices</a></p><h2 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h2><blockquote><p>既然是框架，我们首先应该来聊一聊它解决的问题</p></blockquote><ul><li>使用观察者模式，通过线程传递事件，解决类与类之间的依赖关系，达到解耦的目的</li></ul><h2 id="实现注意"><a href="#实现注意" class="headerlink" title="实现注意"></a>实现注意</h2><ul><li>观察者模式<ul><li>Publish-Subscribe 发布-订阅模式</li><li>发布者和订阅者去除直接耦合，因此降低了系统的整体耦合性</li></ul></li><li>线程安全</li></ul><h2 id="存在的问题及相应思考"><a href="#存在的问题及相应思考" class="headerlink" title="存在的问题及相应思考"></a>存在的问题及相应思考</h2><ul><li>降低了整体的耦合，真的如此？<ul><li>理论上，通过event bus 没有了直接的方法调用；最终实现组件不会直接的产生内部依赖；</li><li>实际上，如果A模块与B模块，为了用Event bus代替A调用一个B的方法，但A与B都要多依赖一个事件作为通信</li><li>另外一个问题，如果A调用B的一个方法，如果调用时类型错了，或是参数的问题都会在编译时提示错误，如果使用Event bus 将不会有错误，但是同样带来的还有方法的错误，导致不易在开发期排查，由用户直接接触到问题</li></ul></li><li>在实现方式上，如果你开发的代码不希望其他开发人员去跟踪事件、生命周期来梳理整个逻辑，简单的方法调用将是哥更好的选择</li></ul><h2 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h2><ul><li>默认不实用 Event Bus 用作通信手段</li><li>当组件间的不易建立起直接的通信，考虑使用 Event bus</li><li>避免组件自己又是发布者又是订阅者</li><li>避免事件链条，即需要多个有序的事件来完成流程</li><li>便携测试来弥补不足依赖，确保组件间的完整</li><li>将事件类分类，整理在相应代表起功能的包中</li></ul><p>补充：</p><ul><li>对事件的发布者和订阅者隔离封装使用(上面第二点)，在划分功能时需要更明确类时作为发布者还是订阅者单独存在的，这一点对长期可维护性非常重要<ul><li>这一点也同时是接口隔离的极佳表现</li></ul></li></ul><h2 id="对于Android开发的使用建议"><a href="#对于Android开发的使用建议" class="headerlink" title="对于Android开发的使用建议"></a>对于Android开发的使用建议</h2><ul><li>推荐使用 EventBus library<ul><li>即使你可以通过 RxJava 短短几行来实现</li><li>就算是很喜欢DIY</li></ul></li><li>默认在所有订阅者使用 <code>ThreadMode.MAIN_ORDERED</code> </li><li>不要将 EventBus放在多线程的情形下进行使用</li><li>粘性事件的使用，代表这将会将应用的一部分状态存储在 EventBus，这种取舍在大多数情况是不合理的</li><li>不应使用 EventBus的注释，如果用到了，你需要重新评价这个设计<ul><li>我想到的情况为，大量使用使用事件导致需要 订阅者索引(Subscriber Index)来辅助索引</li></ul></li></ul><p>如果使用了这个工具，它让你的生活变得更简单。多处这种处理并不是最佳的(non-optimal)，这将导致维护方面的问题，需要小心</p><p>常用场景</p><ul><li>将用户在DialogFragment中的交互同志到其宿主Activity或Fragment</li><li>从Services中发送Activity或Fragment</li><li>多屏状态下，非主线程的通信</li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> ReadingNote </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> ReadingNote </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Activity Lifecycle</title>
      <link href="/2020/02/18/Android-Activity-Lifecycle/"/>
      <url>/2020/02/18/Android-Activity-Lifecycle/</url>
      
        <content type="html"><![CDATA[<p>今年春节在家看到了一篇《Android 开发者成神之路！》的文章，文章翻译自 Vasiliy Zukanov《Android Developer Skills for 2020》。文中提到了很多我想了解的知识，比如这篇《Android Activity Lifecycle》虽然基础，但其中描述的一些内容还是我编程时会出现的错误。我想之后仔细阅读这位大神的博客内容，对关键内容进行整理总结。</p><a id="more"></a><p><a href="https://www.techyourchance.com/android-activity-lifecycle/" target="_blank" rel="noopener">原文地址</a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ol><li>Activity是Android框架中核心组件之一，通常它代表一个界面</li><li>Activity看上去很容易被理解和使用，但是真正重要的是去理解它的生命周期</li><li>对Activity生命周期理解的不够深入，是一个导致Android应用复杂和产生bug的重要原因</li></ol><h2 id="Activity-使用指导"><a href="#Activity-使用指导" class="headerlink" title="Activity 使用指导"></a>Activity 使用指导</h2><h3 id="onCreate-Bundle"><a href="#onCreate-Bundle" class="headerlink" title="onCreate(Bundle)"></a>onCreate(Bundle)</h3><ol><li>onCreate中必须要做的两件事<ul><li>setContentView</li><li>restore saved state</li><li>如果使用依赖注入，则在这里进行注入</li></ul></li><li>onCreate中不要出现的操作<ul><li>订阅被观察者</li><li>功能流程</li><li>开始异步功能流程</li><li>资源分配</li></ul></li><li>当我在决定一段代码逻辑是否属于onCreate时，我会问一个问题：这与初始化一个对象有关系嘛？如果答案是否定的，那我会另外找个地方放置这些代码</li><li>onCreate运行完成后，它将变为“created” state<ul><li><code>created</code>Activity 不应该引起额外的资源分配，不应该接受到其他的事件</li><li><code>created</code>状态等同于,<code>ready, but inactive and isolated</code>状态</li></ul></li></ol><h3 id="onStart"><a href="#onStart" class="headerlink" title="onStart"></a>onStart</h3><blockquote><p>由于用户要配合使用，AndroidFragment会调用<code>onStart()</code>方法。这个方法会将<code>created</code>状态下的Activity变为可以使用的状态<code>started</code>(bring to Life)</p></blockquote><ol><li>以下的操作都应该在onStart中进行<ul><li>View的点击事件的注册</li><li>被观察者的订阅</li><li>反应当前状态下的UI展示（UI update）</li><li>功能流程流程启动</li><li>异步功能流程启动</li><li>资源的分配</li></ul></li><li>对于上述前两点，被观察者的订阅也在<code>onStart()</code>中进行的疑问，我们在 <code>onStop()</code>中进行解释</li></ol><h3 id="onResume"><a href="#onResume" class="headerlink" title="onResume"></a>onResume</h3><blockquote><p>该方法执行后，Activity由 <code>started</code>状态变为<code>resumed</code>状态，代表Activity正在与用户进行交互</p></blockquote><p>对于<code>onResume</code>使用的两个规则</p><ol><li>你不需要<code>onResume</code>方法</li><li>你确实需要<code>onResume</code>方法仅存在很特殊的条件下。我的观点中，该方法应该只被用于开启或移除<code>moving stuff</code>(不太明白作者说的这个情况)</li></ol><h3 id="onPause"><a href="#onPause" class="headerlink" title="onPause"></a>onPause</h3><blockquote><p>在这个方法中，我们应该做的是将<code>onResume()</code>中启动的动画、视频暂停或停止，所以就像<code>onResume()</code>方法，我们应该很少用到<code>onPause()</code>除非一些特殊的情况下。在该方法调用后，Activity会由<code>resumed</code>状态重新回到<code>started</code>状态</p></blockquote><ol><li>选择<code>onPause()</code>状态中处理逻辑，一定是只能在该方法下才能处理的情况。目前只有<ul><li>Activity由于多窗口状态下失去焦点</li><li>Activity被另一个界面遮盖部分，像系统Dialog</li></ul></li><li>相机是一个比较特殊的例子，因为相机目前作为被多个应用同时公用的一个资源<ul><li>可能需要在<code>onPause()</code>释放相机以便其他应用使用相机</li><li>Android10开始，相机在多Activity情形有所调整，具体可以看<a href="https://source.android.com/devices/tech/display/multi_display/multi-resume" target="_blank" rel="noopener">这篇文章</a></li></ul></li></ol><h3 id="onStop"><a href="#onStop" class="headerlink" title="onStop"></a>onStop</h3><blockquote><p>这个方法中我通常会取消全部对被观察者的订阅，并释放全部在<code>onStart()</code>方法中对资源的分配。<code>onStop()</code>执行过后，Activity会变为<code>created</code>状态</p></blockquote><p>为什么我们应该在<code>onStart()</code>与<code>onStop()</code>中注册、取消对被观察者的监听？如果不放在<code>onStop()</code>中，那就只有放在<code>onPause()</code>与<code>onDestory()</code>中</p><ol><li>在<code>onPause()</code>中进行取消订阅，这将意味着如果用户处在多屏模式下，将无法看到应用页面收到消息后的变化的。而用户进入多屏模式下，固然还是需要看到应用在收到消息时产生的变化。</li><li>在<code>onDestory()</code>中进行取消订阅同样也不是一个很好的选择。<ul><li>当应用进入后台，Activity调用<code>onStop()</code>方法后，转变为<code>created</code>状态，应用可能保持这个状态几天甚至是几周。如果依赖中被观察者发生了事件的回调，Activity将在后台持有这些事件。这将是对电池寿命的浪费，甚至会导致不可预期的效果。</li><li>对观察者的注册会导致对内存更高的消费，所以整个应用更容易被Android系统在低内存下杀死</li></ul></li><li>在<code>SDKVersion 19</code>可以安全的在<code>onCreate()</code>对View进行监听的注册，并且不需要取消对它们的监听</li></ol><h3 id="onDestory"><a href="#onDestory" class="headerlink" title="onDestory"></a>onDestory</h3><blockquote><p>这个方法我们应该永远不要重写</p></blockquote><ol><li>如果按照我们规定的在<code>onCreate()</code>中进行了初始化，没有其他的逻辑，在<code>onCreate()</code>真的不需要我们去做什么</li><li>当我去检查Android代码库时,我通常会查看几个常用错误和反设计模式的部分，调整代码使其变为高质量的代码。<code>onDestory</code>的重写就是我去检查的地方</li></ol><h3 id="onSaveInstanceState-Bundle"><a href="#onSaveInstanceState-Bundle" class="headerlink" title="onSaveInstanceState(Bundle)"></a>onSaveInstanceState(Bundle)</h3><blockquote><p>这个方法一般用于在界面配置状态改变时进行保存数据</p></blockquote><ol><li>在这个方法中唯一需要做的事情就是保存当前的状态</li><li>关于Activity中如果有Fragment，若<code>Fragment transaction</code>在该方法执行后被<code>commit</code>，将会出现<code>IllegalStateException</code>异常，以下有几种处理方式<ul><li>不去处理，接受这些极端的bug造成的崩溃</li><li>使用<code>commitAllowingStateLoss()</code>，并接受一些保存状态的丢失</li><li>界面中不再使用<code>Fragment</code></li><li>对异常情况挨个进行处理，这可能导致有些漏掉的情况依然会导致崩溃</li></ul></li><li><code>onSaveInstanceState</code>的调用时机<ul><li>在23版之前，该方法会在<code>onStop</code>之前调用</li><li>在23版之后，该方法会在<code>onStop</code>之后调用</li></ul></li><li>Google关于Lifecycle使用的介绍中，也描述了这个场景及相应的解决方法:<a href="https://developer.android.google.cn/topic/libraries/architecture/lifecycle#onStop-and-savedState" target="_blank" rel="noopener">处理ON_STOP事件</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> ReadingNote </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> ReadingNote </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单元测试学习笔记</title>
      <link href="/2019/12/02/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/12/02/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>本文主要介绍开始单元测试的一些思路。自从接触了测试驱动开发，一直想在Android开发时引入单元测试来提高开发的效率与质量。国内在单元测试方面的实践经验不太容易找，本篇文章是在大佬的博文基础上做了一些整理。</p><a id="more"></a><blockquote><p>持续更新</p></blockquote><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><ol><li>什么是单元测试<ul><li>对于OOP领域 指一个类的一个方法，即测试摸一个类的某一个方法是否能正常工作</li><li>测试的类只关注对 共有方法，非共有方法是类内部的细节，我们并不关心。</li><li>关注某一个方法的输入与输出</li></ul></li><li>android项目里运行单元测试<ul><li>Android gradle project，源码默认在 <code>src/main/java</code>，单元测试代码在<code>src/test/java</code>下</li><li>单元测试中的包名可以随意定，一般使用 包名+test，如果只使用包名，重命名包名时会修改源码的包名，造成麻烦</li></ul></li></ol><h2 id="Android单元测试的痛点"><a href="#Android单元测试的痛点" class="headerlink" title="Android单元测试的痛点"></a>Android单元测试的痛点</h2><ol><li>JVM上运行纯Junit单元测试时是不能使用Android相关的类的<ul><li>使用Android仪器测试，将单元测试运行在模拟器或真机上。 慢</li><li>使用一定架构来隔离，比如MVP Presenter层 完全使用Java实现，进行单元测试， View层等Android相关的代码不测试</li><li>使用Robolectric，在JVM上实现安卓模拟的环境；<ul><li>大神经验：如果架构将android代码和java代码完全分离，还是尽量不用，因为这个还是需要merge一些资源，速度还是慢；如果刚开始，从Robolectric开始是完全OK的。</li></ul></li></ul></li><li>痛点解决方案时间对比<ul><li>Instrumentation： 几十秒 取决于app大小</li><li>Robolectric：10秒左右</li><li>JUnit： 几秒钟内</li></ul></li></ol><h2 id="单元测试使用依赖注入"><a href="#单元测试使用依赖注入" class="headerlink" title="单元测试使用依赖注入"></a>单元测试使用依赖注入</h2><ol><li>什么是依赖注入，<br> 简单说就是一个类中使用的内部对象，不在类内部去创建，而是由外部创建好对象，再通过某种方式set给类。比如DataActivity，用到的DataModel对象，DataModel对象的创建过程不再DataActivity内，而是由外部创建好在设置到DataActivity中</li><li>Dagger2中的几个概念<ul><li>Client： 使用到别的类的地方</li><li>Dependency：被其他类使用的类</li><li>Module： 用于创建Dependency的地方</li><li>Component：提供Client使用Dependency的统一接口</li></ul></li><li>Dagger2 提供Client获取Dependency的一种框架</li><li>单元测试使用依赖注入的方式<ul><li>首先，要明确 Dependency 产生的地方是在 Moudel，而不是Component</li><li>正式代码中，使用正常的Module生成正常的dependency,测试环境中使用测试Module生产mock的dependency</li></ul></li></ol><h2 id="经验总结"><a href="#经验总结" class="headerlink" title="经验总结"></a>经验总结</h2><h3 id="Android单元测试方式"><a href="#Android单元测试方式" class="headerlink" title="Android单元测试方式"></a>Android单元测试方式</h3><blockquote><p>Android项目进行单元测试的基本流程</p></blockquote><h3 id="哪些东西需要测试？"><a href="#哪些东西需要测试？" class="headerlink" title="哪些东西需要测试？"></a>哪些东西需要测试？</h3><ol><li>所有的 Model，Presenter/ViewModel，Api，Utils的public方法</li><li>Data类中，除了getter，setter，toString等自动生成的方法之外的逻辑部分</li><li>自定义View的功能，比如setData之后界面的变化，简单的交互，比如点击事件，复杂的交互一般不测试，不如touch以及滑动事件等等</li><li>Activity的主要功能：比如view是不是存在、显示数据、错误信息、简单的点击事件等。比较复杂的交互一般不测试，比如onTouch以及view的样式、位置等</li></ol><h3 id="大神遇到的坑以及practice建议"><a href="#大神遇到的坑以及practice建议" class="headerlink" title="大神遇到的坑以及practice建议"></a>大神遇到的坑以及practice建议</h3><ol><li><p>Native library<br> 单元测试都不支持load native library，会报 <code>UnsatisfiedLinkError</code>  </p><p> <strong>出现的情形：</strong></p><ol><li>被测代码里面用到了native lib， 可能需要给<code>System.loadLibrary</code>加上<code>try catch</code></li><li>被测代码用到的第三方lib，一般两种解决情况<ul><li>将用到 <code>native lib</code>的第三方类外面包一层，测试的情况下mock掉<ul><li>优点：是可以在测试的时候随时改变这个类的返回值或行为，</li><li>缺点：需要额外的创建wrapper类</li></ul></li><li>使用 Robolectric ，给类创建一个shadow class<ul><li>优点： 写起来十分简单</li><li>缺点： 随时改变这个类的行为</li></ul></li></ul></li></ol><p> <strong>注：</strong><br> 这两种方法，也是解决 <code>static method</code>,<code>final class/method</code>不能mock的主要方式</p></li><li><p>尽量写出易于测试的代码<br> static method，直接 new object，singleton，Global state 等等这些都不利于测试，应该尽量避免，采用依赖注入来代替这些方式</p></li><li><p>不要重复你的单元测试<br> 不如构建者模式创建的类，其中又一个validator来检验参数情况。这是builder和validator应该分开测试，好处是如果validator的测试改变了，这时就不需要修改builder相关的测试。</p></li><li><p>公共的单元测试library<br> 组件化开发的话，可以抽出一个公共的单元测试类库来做单元测试，里面可以放公共的 helper、utils、rules等等，这将极大的提高写单元测试的速度</p></li><li><p>把Android中的”纯java”代码copy一份到自己的项目里<br> Android中的有些类，比如TextUtils、Color等，这些完全可以copy出来，这样部分功能也可以使用 JUnit而不是Robolectric进行</p></li><li><p>充分发挥JUnit Rule的作用<br> JUnit Rule基本作用是，让你在执行某个测试方法的前后，做一些工作。如果你的测试类中有很多共同的setup，teardown工作，需要结合@Before @After来减少duplication， 如果使用JUnit Rule来完成，会有更大的灵活性。<br> <strong>一个值得实践的Rule:</strong><br> 自定义一个annotation，annotation接受一个String，用于描述测试方法的测试目的。在Rule里面将这个annotation读出来，如果测试没有通过，把这个描述性的String驾到error message里面进行输出。这样在做测试方法的命名就可以比较简单啦。</p></li><li><p>利用AndroidStudio来加快写测试的速度<br> AndroidStudio的很多功能可以帮助我们更快的写代码，比如 code generation和live template。这对写正式代码也适用，但是写测试代码效果更为突出，因为大部分测试代码的结构和风格都是类似的。</p></li><li><p>不要追求完美<br> 刚开始不用追求测试代码的质量与完美，不好写测试的地方可以先放一放，等之后来补。有部分测试总比没有测试好。</p></li></ol><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://chriszou.com/2016/04/25/android-unit-testing-wechat-group-share.html" target="_blank" rel="noopener">Android单元测试在蘑菇街支付金融部门的实践</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> TDD </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> TDD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kotlin 高阶函数</title>
      <link href="/2019/10/28/kotlin-%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/"/>
      <url>/2019/10/28/kotlin-%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>在看以kotlin写的开源项目时，对高阶函数的使用抱有很多疑问，因为使用了lambda表达式，各种缩紧的写法，看代码时被高的一头雾水。于是便进行了学习。文章主要根据官方文档，对kotlin高阶函数的概念及语法进行了介绍，日后也可作为查阅的资料。</p><a id="more"></a><blockquote><p>高阶函数，指使用函数作为参数或是返回值的函数</p></blockquote><h2 id="1-初窥门径"><a href="#1-初窥门径" class="headerlink" title="1. 初窥门径"></a>1. 初窥门径</h2><blockquote><p>我们先看一下官方提供的范例，来了解一下高阶函数</p></blockquote><p>这个范例使用的是fold函数，它的功能是将规定的初始值与容器中的值通过传入的combine函数，返回构建后的结构，以下是fold函数的源码</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> Collection<span class="type">&lt;T&gt;</span>.<span class="title">fold</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    initial: <span class="type">R</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">    combine: (<span class="type">acc</span>: <span class="type">R</span>, <span class="type">nextElement</span>: <span class="type">T</span>) -&gt; <span class="type">R</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>: R &#123;</span><br><span class="line">    <span class="keyword">var</span> accumulator: R = initial</span><br><span class="line">    <span class="keyword">for</span> (element: T <span class="keyword">in</span> <span class="keyword">this</span>) &#123;</span><br><span class="line">        accumulator = combine(accumulator, element)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> accumulator</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码中可以看到，combine函数将会使初始值作为累加器和容器中的值进行操作，最后将累加器的值返回，以下是使用的例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">fold_function_test</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> list = ArrayList&lt;String&gt;()</span><br><span class="line"></span><br><span class="line">        list.add(<span class="string">"b"</span>)</span><br><span class="line">        list.add(<span class="string">"c"</span>)</span><br><span class="line">        list.add(<span class="string">"d"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> combine1 = &#123; a:String,b:String -&gt; a+b &#125;</span><br><span class="line">        <span class="keyword">val</span> result1 = list.fold(<span class="string">"a"</span>, combine1)</span><br><span class="line"></span><br><span class="line">        assertEquals(<span class="string">"abcd"</span>,result1)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> combine2 = &#123;</span><br><span class="line">                a:String,b:String-&gt;</span><br><span class="line">            <span class="keyword">if</span>(a&lt;b)&#123;a&#125;<span class="keyword">else</span>&#123;b&#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> result2 = list.fold(<span class="string">"a"</span>,combine2)</span><br><span class="line">        assertEquals(result2,<span class="string">"a"</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>需要注意的是,函数作为参数传递时，需要使用函数类型(Function types)进行传递</p><h3 id="1-1-函数类型-Function-types"><a href="#1-1-函数类型-Function-types" class="headerlink" title="1.1 函数类型(Function types)"></a>1.1 函数类型(Function types)</h3><blockquote><p>当函数作为参数或是返回值时，需要使用函数类型(Function types)的方式进行定义</p></blockquote><h4 id="函数类型的使用情形"><a href="#函数类型的使用情形" class="headerlink" title="函数类型的使用情形"></a>函数类型的使用情形</h4><blockquote><p>如果想将函数作为参数，或是返回值返回，可以使用下面的方式来申明函数类型</p></blockquote><p>下面情形中的示例代码主要为方便理解，进行的语法展示，不具有实际的使用意义</p><ol><li><p>在函数体中使用如下代码块</p><ul><li>lambda表达式 : <code>{a,b -&gt; a+b}</code></li><li>无名函数(an anonymous function) : <code>fun(s:String):Int {return s.toIntOrNull()?:0}</code><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">fold_function_test</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> list = ArrayList&lt;String&gt;()</span><br><span class="line"></span><br><span class="line">    list.add(<span class="string">"b"</span>)</span><br><span class="line">    list.add(<span class="string">"c"</span>)</span><br><span class="line">    list.add(<span class="string">"d"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> combine1 = &#123; a:String,b:String -&gt; a+b &#125;</span><br><span class="line">    <span class="keyword">val</span> result1 = list.fold(<span class="string">"a"</span>, combine1)</span><br><span class="line"></span><br><span class="line">    assertEquals(<span class="string">"abcd"</span>,result1)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> combine2 =</span><br><span class="line">        <span class="function"><span class="title">fun</span><span class="params">( a:<span class="type">String</span>,b:<span class="type">String</span>)</span></span>:String&#123;</span><br><span class="line">                    <span class="keyword">if</span>(a&lt;b)&#123;</span><br><span class="line">                        <span class="keyword">return</span> a</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> b</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> result2 = list.fold(<span class="string">"a"</span>,combine2)</span><br><span class="line">    assertEquals(result2,<span class="string">"a"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>引用已经存在的函数</p><ul><li><p>全局、局部成员，扩展函数： <code>::convertToZero</code>-<code>convertToZero</code>是定义的一个函数,<code>String::toInt</code></p>  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试辅助类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HigherOrderFunctionHelper</span></span>() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">existFunction</span><span class="params">(method:(<span class="type">String</span>)-&gt;<span class="type">Int</span>)</span></span>:<span class="built_in">Int</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> method(<span class="string">"10"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//单元测试1</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">call_exist_function_test_1</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> obj = HigherOrderFunctionHelper()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> result = obj.existFunction(String::toInt)</span><br><span class="line"></span><br><span class="line">    assertEquals(<span class="number">10</span>,result)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//单元测试2</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">call_exist_function_test_2</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> obj = HigherOrderFunctionHelper()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> result = obj.existFunction(::convertToZero)</span><br><span class="line"></span><br><span class="line">    assertEquals(<span class="number">0</span>,result)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该方法可定义在任意 .kt 文件中</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">convertToZero</span><span class="params">(str:<span class="type">String</span>)</span></span>:<span class="built_in">Int</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>全局，成员的扩展属性:<code>List&lt;Int&gt;::size</code></p>  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试辅助类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HigherOrderFunctionHelper</span></span>() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">listPropertyFunction</span><span class="params">(method:(<span class="type">List</span>&lt;<span class="type">Int</span>&gt;)-&gt;<span class="type">Int</span>)</span></span>:<span class="built_in">Int</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> list = ArrayList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">        list.add(<span class="number">0</span>)</span><br><span class="line">        list.add(<span class="number">1</span>)</span><br><span class="line">        list.add(<span class="number">2</span>)</span><br><span class="line">        list.add(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> method(list)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试方法</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">call_exist_function_test_3</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> obj = HigherOrderFunctionHelper()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> sizeProperty = List&lt;<span class="built_in">Int</span>&gt;::size</span><br><span class="line">    <span class="keyword">val</span> result = obj.listPropertyFunction(sizeProperty)</span><br><span class="line"></span><br><span class="line">    assertEquals(<span class="number">4</span>,result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>构造函数作为函数类型传递  <code>::HigherOrderFunctionHelper</code></p>  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//辅助类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HigherOrderFunctionHelper</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> param1:Any</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(param1:Any) : <span class="keyword">this</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.param1 = param1</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">output</span><span class="params">()</span></span>:Any&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(::param1.isInitialized)&#123;</span><br><span class="line">            <span class="keyword">return</span> param1</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> UninitializedPropertyAccessException(<span class="string">"param1 has not been initialized"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 单元测试</span></span><br><span class="line"><span class="comment"> * 注意: 类中有两个构造函数的情况，这里申明变量时，指定使用的函数类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test(expected = UninitializedPropertyAccessException::class)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">class_constructor_as_param_1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">constructor</span>:()-&gt;HigherOrderFunctionHelper = ::HigherOrderFunctionHelper</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> helper = <span class="keyword">constructor</span>()</span><br><span class="line"></span><br><span class="line">    helper.output()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">class_constructor_as_param_2</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> constructor2:(param:Any)-&gt;HigherOrderFunctionHelper = ::HigherOrderFunctionHelper</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> helper2 = constructor2(<span class="string">"test"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> result2 = helper2.output()</span><br><span class="line"></span><br><span class="line">    assertEquals(<span class="string">"test"</span>,result2)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>一种特殊的情形是，使用某一个对象所具有的方法 <code>helper::output</code>,这里同样要注意函数存在重构的情况下，如何去获取</p></li></ul></li><li><p>将函数类型作为接口继承的自定义类</p> <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义类，该类必须实现 invoke方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FunctionTypeCustomClass</span> : <span class="type"></span></span>(<span class="built_in">Int</span>)-&gt;<span class="built_in">Int</span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">(param1: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> param1*<span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试辅助类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HigherOrderFunctionHelper</span></span>() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">exeInt2Int</span><span class="params">(method:(<span class="type">Int</span>)-&gt;<span class="type">Int</span>)</span></span>:<span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> method(<span class="number">10</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//单元测试</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">custom_class_implement_function_type_test</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> obj = HigherOrderFunctionHelper()</span><br><span class="line">    <span class="keyword">val</span> result = obj.exeInt2Int(FunctionTypeCustomClass())</span><br><span class="line"></span><br><span class="line">    assertEquals(<span class="number">100</span>,result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h5 id="调用一个函数类型的情形"><a href="#调用一个函数类型的情形" class="headerlink" title="调用一个函数类型的情形"></a>调用一个函数类型的情形</h5><p>一个函数类型的值，可以通过<code>f.invoke(x)</code>或者<code>f(x)</code>被调用。</p><h5 id="inline函数"><a href="#inline函数" class="headerlink" title="inline函数"></a>inline函数</h5><p>当需要为高阶函数提供灵活的控制流时，使用 inline函数是十分有益的。可查看<a href="https://kotlinlang.org/docs/reference/inline-functions.html" target="_blank" rel="noopener">官方文档</a></p><h3 id="1-2-Lambda表达式和匿名函数-Lambda-Expression-and-Anonymous-Functions"><a href="#1-2-Lambda表达式和匿名函数-Lambda-Expression-and-Anonymous-Functions" class="headerlink" title="1.2 Lambda表达式和匿名函数 (Lambda Expression and Anonymous Functions)"></a>1.2 Lambda表达式和匿名函数 (Lambda Expression and Anonymous Functions)</h3><blockquote><p>下面介绍一些 Lambda表达式以及匿名函数中的基本概念以及使用方法，有些已经在上述的示例中使用了</p></blockquote><h4 id="Lambda表达式语法"><a href="#Lambda表达式语法" class="headerlink" title="Lambda表达式语法"></a>Lambda表达式语法</h4><ol><li>Lambda表达式被花括号包裹</li><li><code>-&gt;</code>符号，分割了表达式的参数与逻辑体</li><li>逻辑体默认最后一行表示返回值,如果定义了返回结果为 Unit，则返回Unit类型</li><li>定义函数类型变量与Lambda表达式进行匹配 <code>val lambda:(Int,Int)-&gt;Int = {a:Int,b:Int -&gt; a+b}</code></li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">lambda_test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> lambda1:(<span class="built_in">Int</span>,<span class="built_in">Int</span>)-&gt;<span class="built_in">Int</span> = &#123;a:<span class="built_in">Int</span>,b:<span class="built_in">Int</span>-&gt;</span><br><span class="line">        <span class="keyword">val</span> param1 = a*<span class="number">2</span></span><br><span class="line">        <span class="keyword">val</span> param2 = b*<span class="number">2</span></span><br><span class="line">        param1+param2</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> result1 = lambda1(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    assertEquals(<span class="number">6</span>,result1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> lambda2:(<span class="built_in">Int</span>,<span class="built_in">Int</span>)-&gt;<span class="built_in">Unit</span> = &#123;a:<span class="built_in">Int</span>,b:<span class="built_in">Int</span>-&gt;</span><br><span class="line">        <span class="keyword">val</span> param1 = a*<span class="number">2</span></span><br><span class="line">        <span class="keyword">val</span> param2 = b*<span class="number">2</span></span><br><span class="line">        param1+param2</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> result2 = lambda2(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">    assertThat(<span class="built_in">Unit</span>,`<span class="keyword">is</span>`(result2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="lambda-表达式作为最后一个参数"><a href="#lambda-表达式作为最后一个参数" class="headerlink" title="lambda 表达式作为最后一个参数"></a>lambda 表达式作为最后一个参数</h4><ol><li>如果是单参数，则可以省略括号</li><li>如果是作为最后一个参数时，可以放到括号外面</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">fun singleParam(method:(Int)-&gt;Int):Int&#123;</span><br><span class="line">    return method(2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun multiParam(initial:Int,method:(Int)-&gt;Int):Int&#123;</span><br><span class="line">    return method(initial)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">fun lambda_as_last_param_test_1() &#123;</span><br><span class="line">    val result = singleParam &#123; it * 2 &#125;</span><br><span class="line">    assertEquals(4,result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">fun lambda_as_last_param_test_2() &#123;</span><br><span class="line">    val result = multiParam(10) &#123; it * 2 &#125;</span><br><span class="line">    assertEquals(20,result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="it-指代Lambda表达式中，单独一个参数的情况"><a href="#it-指代Lambda表达式中，单独一个参数的情况" class="headerlink" title="it: 指代Lambda表达式中，单独一个参数的情况"></a>it: 指代Lambda表达式中，单独一个参数的情况</h4><p><code>ints.filter { it &gt; 0 } // this literal is of type &#39;(it: Int) -&gt; Boolean&#39;</code></p><h4 id="通过lambda表达式返回一个值"><a href="#通过lambda表达式返回一个值" class="headerlink" title="通过lambda表达式返回一个值"></a>通过lambda表达式返回一个值</h4><p>以下两种方式可以定义lambda表达式的返回体</p><ol><li>逻辑体默认最后一行表示返回值</li><li><code>return@函数名 returnValue</code></li></ol><h4 id="使用下划线表示不用的参数"><a href="#使用下划线表示不用的参数" class="headerlink" title="使用下划线表示不用的参数"></a>使用下划线表示不用的参数</h4><p>如果lambda表达式中，逻辑中有不用的参数，可以使用 <code>_</code>来代替不用的参数</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">singleParamUnused</span><span class="params">(initial:<span class="type">Int</span>,method:(<span class="type">String</span>,<span class="type">Int</span>)-&gt;<span class="type">Int</span>)</span></span>:<span class="built_in">Int</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> method(<span class="string">""</span>,initial)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">multiParamUnused</span><span class="params">(initial:<span class="type">Int</span>,method:(<span class="type">String</span>,<span class="type">Int</span>,<span class="type">String</span>)-&gt;<span class="type">Int</span>)</span></span>:<span class="built_in">Int</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> method(<span class="string">""</span>,initial,<span class="string">""</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">lambda_has_unused_variable</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> lambda:(String,<span class="built_in">Int</span>)-&gt;<span class="built_in">Int</span> = &#123;_,param -&gt; param*<span class="number">10</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> result = singleParamUnused(<span class="number">10</span>, lambda)</span><br><span class="line">    assertEquals(<span class="number">100</span>,result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">lambda_has_unused_variable_2</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> lambda:(String,<span class="built_in">Int</span>,String)-&gt;<span class="built_in">Int</span> = &#123;_,param,_ -&gt; param*<span class="number">10</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> result = multiParamUnused(<span class="number">10</span>, lambda)</span><br><span class="line">    assertEquals(<span class="number">100</span>,result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解构声明-Destructuring-Declarations"><a href="#解构声明-Destructuring-Declarations" class="headerlink" title="解构声明(Destructuring Declarations)"></a>解构声明(Destructuring Declarations)</h4><p>相关内容请查看<a href="https://kotlinlang.org/docs/reference/multi-declarations.html#destructuring-in-lambdas-since-11" target="_blank" rel="noopener">官方文档</a></p><h4 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h4><p>与Lambda表达式相比，匿名函数可以清晰的定义返回值的类型</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">fun</span><span class="params">(x:<span class="type">Int</span>,y:<span class="type">Int</span>)</span></span>:<span class="built_in">Int</span> = x + y</span><br></pre></td></tr></table></figure><h4 id="有关闭包"><a href="#有关闭包" class="headerlink" title="有关闭包"></a>有关闭包</h4><p>变量声明在闭包外，这些变量可以在闭包内被捕获，并能够在Lambda表达式中被修改。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">ints.filter &#123; it &gt; <span class="number">0</span> &#125;.forEach &#123;</span><br><span class="line">    sum += it</span><br><span class="line">&#125;</span><br><span class="line">print(sum)</span><br></pre></td></tr></table></figure><h4 id="Function-literals-with-receiver"><a href="#Function-literals-with-receiver" class="headerlink" title="Function literals with receiver"></a>Function literals with receiver</h4><p>表示方式 <code>A.(B) -&gt; C</code>,可以使用两种方式进行申明：</p><ol><li>Lambda表达式 <code>val sum: Int.(Int)-&gt; Int = {other -&gt; plus(other)}</code></li><li>匿名函数 <code>val sum = fun Int.(other:Int):Int = this + other</code></li></ol><p>下面例子简单介绍了这种情况:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">function_literal_with_receiver_test1</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> func:String.(<span class="built_in">Int</span>)-&gt;String = &#123; times -&gt;<span class="keyword">this</span>.repeat(times) &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> str = <span class="string">"test"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> repeat:(String,<span class="built_in">Int</span>)-&gt;String = func</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> result = repeat(str, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    assertEquals(<span class="string">"testtesttest"</span>,result)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">repeat</span><span class="params">(method:<span class="type">String</span>.(<span class="type">Int</span>)-&gt;<span class="type">String</span>)</span></span>:String&#123;</span><br><span class="line">    <span class="keyword">val</span> str = <span class="string">"hehe!"</span></span><br><span class="line">    <span class="keyword">return</span> str.method(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">function_literal_with_receiver_test2</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> func:String.(<span class="built_in">Int</span>)-&gt;String = &#123; times -&gt;<span class="keyword">this</span>.repeat(times) &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> result = repeat(func)</span><br><span class="line">    assertEquals(<span class="string">"hehe!hehe!hehe!"</span>,result)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-小结"><a href="#1-3-小结" class="headerlink" title="1.3 小结"></a>1.3 小结</h3><p>第一部分根据官方文档，介绍了高阶函数的定义以及各类情况，并提供了简单的例子。但是放在实际项目中该如何使用还需要更进一步的思考。</p><hr><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><p><a href="https://kotlinlang.org/docs/reference/lambdas.html" target="_blank" rel="noopener">Higher-Order Functions and Lambdas</a><br><a href="https://juejin.im/post/5b198c675188257d7a49b3ec" target="_blank" rel="noopener">Kotlin——高级篇（二）：高阶函数详解与标准的高阶函数使用</a></p>]]></content>
      
      
      <categories>
          
          <category> kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac环境Hexo+Github搭建博客</title>
      <link href="/2019/10/16/Mac%E7%8E%AF%E5%A2%83Hexo-Github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2019/10/16/Mac%E7%8E%AF%E5%A2%83Hexo-Github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>文章主要记录了我是如何在Mac环境下，使用 Hexo+Github 搭建博客的…</p><a id="more"></a><h2 id="基本使用命令"><a href="#基本使用命令" class="headerlink" title="基本使用命令"></a>基本使用命令</h2><ol><li><code>hexo d -g</code> 生成部署</li><li><code>hexo s -g</code> 生成预览</li><li><code>hexo d</code> 上传网页文件到github</li><li><code>hexo new post &quot;article title&quot;</code> 创建博文文件</li></ol><h3 id="命令详述"><a href="#命令详述" class="headerlink" title="命令详述"></a>命令详述</h3><ol><li><code>hexo server</code> <code>hexo s</code> 启动本地服务,预览博客</li><li><code>hexo generate</code> <code>hexo g</code> 生成博客网页文件</li><li><code>hexo deploy</code> <code>hexo d</code>  上传网页文件到github</li><li><code>hexo new ...</code><ul><li><code>hexo new post &quot;article name&quot;</code></li><li><code>hexo new page &quot;page name&quot;</code></li></ul></li><li><code>hexo clean</code></li></ol><h2 id="搭建过程"><a href="#搭建过程" class="headerlink" title="搭建过程"></a>搭建过程</h2><ol><li><p><a href="#build_blog_1">安装node.js</a></p></li><li><p>安装git，并配置git账号信息</p></li><li><p>注册github账号并创建项目</p><ul><li><strong>注：</strong>项目名称必须为 github名称.github.io</li><li>在 <code>项目-&gt;Settings-&gt;Source</code>选择为 <code>master branch</code></li></ul></li><li><p>安装Hexo,并创建本地博客项目</p><ul><li>创建博客维护文件夹，并切换至文件夹下</li><li>在控制台中进行操作<ul><li><code>npm i hexo-cli -g</code> 进行安装hexo</li><li><code>hexo -v</code>验证安装是否成功</li><li><code>hexo init</code>初始化文件夹，注意要在你创建的博客维护文件夹下</li><li><code>npm install</code> 安装必备的组件</li><li><code>hexo g</code>生成静态页面</li><li><code>hexo s</code> 打开本地服务器，<code>http://localhost:4000/</code>查看博客</li></ul></li></ul></li><li><p>连接Github与本地博客文件夹</p><ul><li>修改博客文件夹根目录下 <code>_config.yml</code>文件</li><li>找到<code>deploy</code>进行修改  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">    type: git</span><br><span class="line">    repository: 项目Clone地址</span><br><span class="line">    branch: master</span><br></pre></td></tr></table></figure></li></ul></li><li><p>写文章与发布文章</p><ul><li>安装扩展 <code>npm i hexo-deployer-git</code></li><li><code>hexo new post &quot;article title&quot;</code> 新建一篇文章</li><li>在 <code>博客目录\source\_posts</code> 找到新建的文件进行编辑</li><li><code>hexo g</code> 生成静态页面</li><li><code>hexo s</code> 本地预览</li><li><code>hexo d</code> 上传到github</li></ul></li></ol><h3 id="build_blog_1">安装node.js</h3>Mac下安装方式，参考文章[[Node.js]在mac上安装node.js](https://www.jianshu.com/p/3b30c4c846d1)<hr><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="1-使用自己的域名"><a href="#1-使用自己的域名" class="headerlink" title="1. 使用自己的域名"></a>1. 使用自己的域名</h3><ol><li>在 <code>[local_blog_path]/source</code> 新建 CNAME文件,填写自己的域名</li><li>在自己申请域名的网站，设置域名解析</li></ol><h3 id="2-博客维护设备转移"><a href="#2-博客维护设备转移" class="headerlink" title="2. 博客维护设备转移"></a>2. 博客维护设备转移</h3><ul><li>多个设备如何同时维护一个博客</li><li>如何更换设备重新维护博客</li></ul><h3 id="3-设置主题"><a href="#3-设置主题" class="headerlink" title="3. 设置主题"></a>3. 设置主题</h3><ol><li><p><a href="https://hexo.io/themes/" target="_blank" rel="noopener">Hexo 主题</a> 中挑选主题</p></li><li><p>我使用的是 <a href="https://xaoxuu.com/" target="_blank" rel="noopener">MatreialX 演示</a> 主题</p><ul><li><p>关于中查看详细使用方法 <a href="https://xaoxuu.com/wiki/material-x/" target="_blank" rel="noopener">MaterialX</a></p></li><li><p><code>curl -s https://xaoxuu.com/install | sh -s hexo.sh</code></p><ul><li><a href="https://xaoxuu.com/wiki/hexo.sh/" target="_blank" rel="noopener">hexo.sh 使用文档</a></li></ul></li><li><p>主题的修改是通过 <code>_config.yml</code> 文件夹下</p><ul><li><code>theme: material-x</code> 进行配置</li><li><code>博客目录/themes</code>下放置各主题方案，配置文件中主题配置要与该目录下文件保持一致</li></ul></li><li><p>标签</p><ul><li><p>创建<code>博客项目路径/source/blog/tags/index.md</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">layout: tag</span><br><span class="line">index: true</span><br><span class="line">title: 所有标签</span><br><span class="line">---</span><br></pre></td></tr></table></figure><ul><li>创建的文章时，<code>Front-matter</code>中使用<code>tags: [标签A, 标签B]</code></li></ul></li></ul></li><li><p>文章分类 </p><ul><li><p>创建<code>博客项目路径/source/blog/categories/index.md</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">layout: category</span><br><span class="line">index: true</span><br><span class="line">title: 所有分类</span><br><span class="line">---</span><br></pre></td></tr></table></figure></li><li><p>创建的文章时，<code>Front-matter</code>中添加<code>categories: [分类A, 分类B]</code> <a href="https://xaoxuu.com/wiki/material-x/pages/index.html#文章分类" target="_blank" rel="noopener">categories</a></p></li></ul></li><li><p>最近文章</p><ul><li><code>npm i -S hexo-related-popular-posts</code> 安装插件</li></ul></li><li><p>列表中文章摘要</p><ul><li>编写的文章中 使用<code>&lt;!-- more --&gt;</code>，该标记之前的信息会作为摘要展示</li></ul></li><li><p>设置个人信息</p></li></ul></li></ol><hr><p>参考文章:<br><a href="https://hexo.io/docs/" target="_blank" rel="noopener">hexo官方文档</a><br><a href="https://godweiyang.com/2018/04/13/hexo-blog/#toc-heading-7" target="_blank" rel="noopener">超详细Hexo+Github博客搭建小白教程</a><br><a href="https://github.com/HarleyWang93/blog/issues/1" target="_blank" rel="noopener">Hexo + GitHub (Coding) Pages 搭建博客</a><br><a href="https://blog.csdn.net/xudailong_blog/article/details/78762262" target="_blank" rel="noopener">Github搭建个人博客</a><br><a href="https://juejin.im/post/5a71a4f9518825733a3105ac" target="_blank" rel="noopener">GitHub Pages自定义域名</a><br><a href="https://zhuanlan.zhihu.com/p/22498474" target="_blank" rel="noopener">Hexo(2)-部署博客及更新博文</a><br><a href="https://blog.csdn.net/u011475210/article/details/79023429" target="_blank" rel="noopener">我的个人博客之旅：从jekyll到hexo</a></p>]]></content>
      
      
      <categories>
          
          <category> Other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Other </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ndk开发流程</title>
      <link href="/2019/10/12/ndk%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/"/>
      <url>/2019/10/12/ndk%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>本文介绍了 Android 如何调用C/C++ 的native代码，比较基础。</p><a id="more"></a><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><p><a href="https://juejin.im/post/5c3b01016fb9a049f81984bb" target="_blank" rel="noopener">NDK开发入门终极教程</a></p><h2 id="Android-调用-C-C-native代码"><a href="#Android-调用-C-C-native代码" class="headerlink" title="Android 调用 C/C++ native代码"></a>Android 调用 C/C++ native代码</h2><ol><li><p>配置NDK</p><ul><li>AndroidStudio SDKManager中下载NDK相关工具</li><li>SDK路径下，找到ndk路径<ul><li>旧版路径为 $SDK_PATH/ndk-bundle</li><li>新版路径为 $SDK_PATH/ndk/ndk_version ,新版本可切换不同版本</li></ul></li><li>配置系统环境变量<ul><li>mac下 <code>/etc/profile</code><ul><li><code>PATH = $SDK_PATH/ndk-bundle</code></li><li><code>source /etc/profile</code></li></ul></li></ul></li></ul></li><li><p>Android项目下创建调用native方法的类</p><ul><li>声明native函数</li><li>加载native函数动态库</li></ul></li><li><p>实现Android项目中类文件所声明的native方法</p><ul><li><p>方式一 直接编写c/c++文件:</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by Yu. on 2019-10-12.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">JNIEXPORT jstring JNICALL Java_com_dayizhihui_dayishi_drugstore_feature_test_crash_JNICrashTest_makeCrashABRT</span><br><span class="line">(JNIEnv *env, jobject obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"makeCrashABRT() execute.."</span>);</span><br><span class="line">    <span class="keyword">return</span> env-&gt;NewStringUTF(<span class="string">"makeCrashABRT"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">JNIEXPORT jstring JNICALL Java_com_dayizhihui_dayishi_drugstore_feature_test_crash_JNICrashTest_makeCrashSEGV</span><br><span class="line">(JNIEnv *env, jobject obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"makeCrashSEGV() execute.."</span>);</span><br><span class="line">    <span class="keyword">return</span> env-&gt;NewStringUTF(<span class="string">"makeCrashSEGV"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></li><li><p>方式二 先根据java源文件生成class文件，再使用class文件生成 .h头文件，利用头文件编写c/c++源文件</p><ul><li><code>javac .../TestJNI.java -d ./bin</code> 编译生成class文件</li><li><code>javah -jni -classpath ./bin -d ./jni com.study.jnilearn.TestJNI</code> 生成头文件</li><li>编写源文件  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by Yu. on 2019-10-12.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"com_dayizhihui_dayishi_drugstore_feature_test_crash_JNICrashTest.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">JNIEXPORT jstring JNICALL Java_com_dayizhihui_dayishi_drugstore_feature_test_crash_JNICrashTest_makeCrashABRT</span><br><span class="line">(JNIEnv *env, jobject obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"makeCrashABRT() execute.."</span>);</span><br><span class="line">    <span class="keyword">return</span> env-&gt;NewStringUTF(<span class="string">"makeCrashABRT"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JNIEXPORT jstring JNICALL Java_com_dayizhihui_dayishi_drugstore_feature_test_crash_JNICrashTest_makeCrashSEGV</span><br><span class="line">(JNIEnv *env, jobject obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"makeCrashSEGV() execute.."</span>);</span><br><span class="line">    <span class="keyword">return</span> env-&gt;NewStringUTF(<span class="string">"makeCrashSEGV"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>准备生成so库的文件</p><ul><li><p>创建jni文件夹</p></li><li><p>将第三步编写的源文件放入</p></li><li><p>在jni文件夹下创建<code>Android.mk</code></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_PATH := $(call my-dir)</span><br><span class="line"></span><br><span class="line">include $(CLEAR_VARS)</span><br><span class="line"></span><br><span class="line">LOCAL_MODULE := ndk-crash-test</span><br><span class="line">LOCAL_SRC_FILES := test.cpp</span><br><span class="line"></span><br><span class="line">include $(BUILD_SHARED_LIBRARY)</span><br></pre></td></tr></table></figure></li><li><p>在jni文件夹下创建<code>Applicaion.mk</code></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">APP_PLATFORM := android-21</span><br><span class="line">APP_ABI := armeabi-v7a</span><br></pre></td></tr></table></figure><ul><li>APP_ABI 表示使用的架构平台, Android可通过<code>Build.SUPPORTED_ABIS</code>查看支持的架构列表，列表从上到下为支持的好的顺序</li><li>APP_PLATFORM 表示编译使用的版本, 可在sdk/ndk-bundle/platform下查看版本</li></ul></li></ul></li><li><p>切换到jni目录的父目录，执行 <code>ndk-build</code></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> NDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> NDK </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
