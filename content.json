{"meta":{"title":"Huasababy","subtitle":null,"description":null,"author":"Huasababy","url":"http://yoursite.com","root":"/"},"pages":[{"title":"","date":"2020-03-02T10:39:57.069Z","updated":"2020-03-02T10:34:22.012Z","comments":true,"path":"googled7671a8e1f1cb84e.html","permalink":"http://yoursite.com/googled7671a8e1f1cb84e.html","excerpt":"","text":"google-site-verification: googled7671a8e1f1cb84e.html"},{"title":"categories","date":"2020-04-03T12:25:53.000Z","updated":"2020-04-03T12:25:53.900Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-04-03T12:23:21.000Z","updated":"2020-04-03T12:23:21.821Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2019-10-16T17:56:09.800Z","updated":"2019-10-16T17:56:09.800Z","comments":true,"path":"blog/tags/index.html","permalink":"http://yoursite.com/blog/tags/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2019-10-16T17:55:25.531Z","updated":"2019-10-16T17:55:25.331Z","comments":true,"path":"blog/categories/index.html","permalink":"http://yoursite.com/blog/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Android Activity Lifecycle","slug":"Android-Activity-Lifecycle","date":"2020-02-18T08:30:34.000Z","updated":"2020-03-24T08:46:12.417Z","comments":true,"path":"2020/02/18/Android-Activity-Lifecycle/","link":"","permalink":"http://yoursite.com/2020/02/18/Android-Activity-Lifecycle/","excerpt":"今年春节在家看到了一篇《Android 开发者成神之路！》的文章，文章翻译自 Vasiliy Zukanov《Android Developer Skills for 2020》。文中提到了很多我想了解的知识，比如这篇《Android Activity Lifecycle》虽然基础，但其中描述的一些内容还是我编程时会出现的错误。我想之后仔细阅读这位大神的博客内容，对关键内容进行整理总结。","text":"今年春节在家看到了一篇《Android 开发者成神之路！》的文章，文章翻译自 Vasiliy Zukanov《Android Developer Skills for 2020》。文中提到了很多我想了解的知识，比如这篇《Android Activity Lifecycle》虽然基础，但其中描述的一些内容还是我编程时会出现的错误。我想之后仔细阅读这位大神的博客内容，对关键内容进行整理总结。 原文地址 简介 Activity是Android框架中核心组件之一，通常它代表一个界面 Activity看上去很容易被理解和使用，但是真正重要的是去理解它的生命周期 对Activity生命周期理解的不够深入，是一个导致Android应用复杂和产生bug的重要原因 Activity 使用指导onCreate(Bundle) onCreate中必须要做的两件事 setContentView restore saved state 如果使用依赖注入，则在这里进行注入 onCreate中不要出现的操作 订阅被观察者 功能流程 开始异步功能流程 资源分配 当我在决定一段代码逻辑是否属于onCreate时，我会问一个问题：这与初始化一个对象有关系嘛？如果答案是否定的，那我会另外找个地方放置这些代码 onCreate运行完成后，它将变为“created” state createdActivity 不应该引起额外的资源分配，不应该接受到其他的事件 created状态等同于,ready, but inactive and isolated状态 onStart 由于用户要配合使用，AndroidFragment会调用onStart()方法。这个方法会将created状态下的Activity变为可以使用的状态started(bring to Life) 以下的操作都应该在onStart中进行 View的点击事件的注册 被观察者的订阅 反应当前状态下的UI展示（UI update） 功能流程流程启动 异步功能流程启动 资源的分配 对于上述前两点，被观察者的订阅也在onStart()中进行的疑问，我们在 onStop()中进行解释 onResume 该方法执行后，Activity由 started状态变为resumed状态，代表Activity正在与用户进行交互 对于onResume使用的两个规则 你不需要onResume方法 你确实需要onResume方法仅存在很特殊的条件下。我的观点中，该方法应该只被用于开启或移除moving stuff(不太明白作者说的这个情况) onPause 在这个方法中，我们应该做的是将onResume()中启动的动画、视频暂停或停止，所以就像onResume()方法，我们应该很少用到onPause()除非一些特殊的情况下。在该方法调用后，Activity会由resumed状态重新回到started状态 选择onPause()状态中处理逻辑，一定是只能在该方法下才能处理的情况。目前只有 Activity由于多窗口状态下失去焦点 Activity被另一个界面遮盖部分，像系统Dialog 相机是一个比较特殊的例子，因为相机目前作为被多个应用同时公用的一个资源 可能需要在onPause()释放相机以便其他应用使用相机 Android10开始，相机在多Activity情形有所调整，具体可以看这篇文章 onStop 这个方法中我通常会取消全部对被观察者的订阅，并释放全部在onStart()方法中对资源的分配。onStop()执行过后，Activity会变为created状态 为什么我们应该在onStart()与onStop()中注册、取消对被观察者的监听？如果不放在onStop()中，那就只有放在onPause()与onDestory()中 在onPause()中进行取消订阅，这将意味着如果用户处在多屏模式下，将无法看到应用页面收到消息后的变化的。而用户进入多屏模式下，固然还是需要看到应用在收到消息时产生的变化。 在onDestory()中进行取消订阅同样也不是一个很好的选择。 当应用进入后台，Activity调用onStop()方法后，转变为created状态，应用可能保持这个状态几天甚至是几周。如果依赖中被观察者发生了事件的回调，Activity将在后台持有这些事件。这将是对电池寿命的浪费，甚至会导致不可预期的效果。 对观察者的注册会导致对内存更高的消费，所以整个应用更容易被Android系统在低内存下杀死 在SDKVersion 19可以安全的在onCreate()对View进行监听的注册，并且不需要取消对它们的监听 onDestory 这个方法我们应该永远不要重写 如果按照我们规定的在onCreate()中进行了初始化，没有其他的逻辑，在onCreate()真的不需要我们去做什么 当我去检查Android代码库时,我通常会查看几个常用错误和反设计模式的部分，调整代码使其变为高质量的代码。onDestory的重写就是我去检查的地方 onSaveInstanceState(Bundle) 这个方法一般用于在界面配置状态改变时进行保存数据 在这个方法中唯一需要做的事情就是保存当前的状态 关于Activity中如果有Fragment，若Fragment transaction在该方法执行后被commit，将会出现IllegalStateException异常，以下有几种处理方式 不去处理，接受这些极端的bug造成的崩溃 使用commitAllowingStateLoss()，并接受一些保存状态的丢失 界面中不再使用Fragment 对异常情况挨个进行处理，这可能导致有些漏掉的情况依然会导致崩溃 onSaveInstanceState的调用时机 在23版之前，该方法会在onStop之前调用 在23版之后，该方法会在onStop之后调用 Google关于Lifecycle使用的介绍中，也描述了这个场景及相应的解决方法:处理ON_STOP事件","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"ReadingNote","slug":"Android/ReadingNote","permalink":"http://yoursite.com/categories/Android/ReadingNote/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"ReadingNote","slug":"ReadingNote","permalink":"http://yoursite.com/tags/ReadingNote/"}]},{"title":"单元测试学习笔记","slug":"单元测试学习笔记","date":"2019-12-02T05:03:21.000Z","updated":"2019-12-02T10:03:29.952Z","comments":true,"path":"2019/12/02/单元测试学习笔记/","link":"","permalink":"http://yoursite.com/2019/12/02/单元测试学习笔记/","excerpt":"本文主要介绍开始单元测试的一些思路。自从接触了测试驱动开发，一直想在Android开发时引入单元测试来提高开发的效率与质量。国内在单元测试方面的实践经验不太容易找，本篇文章是在大佬的博文基础上做了一些整理。","text":"本文主要介绍开始单元测试的一些思路。自从接触了测试驱动开发，一直想在Android开发时引入单元测试来提高开发的效率与质量。国内在单元测试方面的实践经验不太容易找，本篇文章是在大佬的博文基础上做了一些整理。 持续更新 单元测试 什么是单元测试 对于OOP领域 指一个类的一个方法，即测试摸一个类的某一个方法是否能正常工作 测试的类只关注对 共有方法，非共有方法是类内部的细节，我们并不关心。 关注某一个方法的输入与输出 android项目里运行单元测试 Android gradle project，源码默认在 src/main/java，单元测试代码在src/test/java下 单元测试中的包名可以随意定，一般使用 包名+test，如果只使用包名，重命名包名时会修改源码的包名，造成麻烦 Android单元测试的痛点 JVM上运行纯Junit单元测试时是不能使用Android相关的类的 使用Android仪器测试，将单元测试运行在模拟器或真机上。 慢 使用一定架构来隔离，比如MVP Presenter层 完全使用Java实现，进行单元测试， View层等Android相关的代码不测试 使用Robolectric，在JVM上实现安卓模拟的环境； 大神经验：如果架构将android代码和java代码完全分离，还是尽量不用，因为这个还是需要merge一些资源，速度还是慢；如果刚开始，从Robolectric开始是完全OK的。 痛点解决方案时间对比 Instrumentation： 几十秒 取决于app大小 Robolectric：10秒左右 JUnit： 几秒钟内 单元测试使用依赖注入 什么是依赖注入， 简单说就是一个类中使用的内部对象，不在类内部去创建，而是由外部创建好对象，再通过某种方式set给类。比如DataActivity，用到的DataModel对象，DataModel对象的创建过程不再DataActivity内，而是由外部创建好在设置到DataActivity中 Dagger2中的几个概念 Client： 使用到别的类的地方 Dependency：被其他类使用的类 Module： 用于创建Dependency的地方 Component：提供Client使用Dependency的统一接口 Dagger2 提供Client获取Dependency的一种框架 单元测试使用依赖注入的方式 首先，要明确 Dependency 产生的地方是在 Moudel，而不是Component 正式代码中，使用正常的Module生成正常的dependency,测试环境中使用测试Module生产mock的dependency 经验总结Android单元测试方式 Android项目进行单元测试的基本流程 哪些东西需要测试？ 所有的 Model，Presenter/ViewModel，Api，Utils的public方法 Data类中，除了getter，setter，toString等自动生成的方法之外的逻辑部分 自定义View的功能，比如setData之后界面的变化，简单的交互，比如点击事件，复杂的交互一般不测试，不如touch以及滑动事件等等 Activity的主要功能：比如view是不是存在、显示数据、错误信息、简单的点击事件等。比较复杂的交互一般不测试，比如onTouch以及view的样式、位置等 大神遇到的坑以及practice建议 Native library 单元测试都不支持load native library，会报 UnsatisfiedLinkError 出现的情形： 被测代码里面用到了native lib， 可能需要给System.loadLibrary加上try catch 被测代码用到的第三方lib，一般两种解决情况 将用到 native lib的第三方类外面包一层，测试的情况下mock掉 优点：是可以在测试的时候随时改变这个类的返回值或行为， 缺点：需要额外的创建wrapper类 使用 Robolectric ，给类创建一个shadow class 优点： 写起来十分简单 缺点： 随时改变这个类的行为 注： 这两种方法，也是解决 static method,final class/method不能mock的主要方式 尽量写出易于测试的代码 static method，直接 new object，singleton，Global state 等等这些都不利于测试，应该尽量避免，采用依赖注入来代替这些方式 不要重复你的单元测试 不如构建者模式创建的类，其中又一个validator来检验参数情况。这是builder和validator应该分开测试，好处是如果validator的测试改变了，这时就不需要修改builder相关的测试。 公共的单元测试library 组件化开发的话，可以抽出一个公共的单元测试类库来做单元测试，里面可以放公共的 helper、utils、rules等等，这将极大的提高写单元测试的速度 把Android中的”纯java”代码copy一份到自己的项目里 Android中的有些类，比如TextUtils、Color等，这些完全可以copy出来，这样部分功能也可以使用 JUnit而不是Robolectric进行 充分发挥JUnit Rule的作用 JUnit Rule基本作用是，让你在执行某个测试方法的前后，做一些工作。如果你的测试类中有很多共同的setup，teardown工作，需要结合@Before @After来减少duplication， 如果使用JUnit Rule来完成，会有更大的灵活性。 一个值得实践的Rule: 自定义一个annotation，annotation接受一个String，用于描述测试方法的测试目的。在Rule里面将这个annotation读出来，如果测试没有通过，把这个描述性的String驾到error message里面进行输出。这样在做测试方法的命名就可以比较简单啦。 利用AndroidStudio来加快写测试的速度 AndroidStudio的很多功能可以帮助我们更快的写代码，比如 code generation和live template。这对写正式代码也适用，但是写测试代码效果更为突出，因为大部分测试代码的结构和风格都是类似的。 不要追求完美 刚开始不用追求测试代码的质量与完美，不好写测试的地方可以先放一放，等之后来补。有部分测试总比没有测试好。 参考文章Android单元测试在蘑菇街支付金融部门的实践","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"TDD","slug":"Android/TDD","permalink":"http://yoursite.com/categories/Android/TDD/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"TDD","slug":"TDD","permalink":"http://yoursite.com/tags/TDD/"}]},{"title":"kotlin 高阶函数","slug":"kotlin-高阶函数","date":"2019-10-28T11:36:10.000Z","updated":"2019-10-28T11:45:00.121Z","comments":true,"path":"2019/10/28/kotlin-高阶函数/","link":"","permalink":"http://yoursite.com/2019/10/28/kotlin-高阶函数/","excerpt":"在看以kotlin写的开源项目时，对高阶函数的使用抱有很多疑问，因为使用了lambda表达式，各种缩紧的写法，看代码时被高的一头雾水。于是便进行了学习。文章主要根据官方文档，对kotlin高阶函数的概念及语法进行了介绍，日后也可作为查阅的资料。","text":"在看以kotlin写的开源项目时，对高阶函数的使用抱有很多疑问，因为使用了lambda表达式，各种缩紧的写法，看代码时被高的一头雾水。于是便进行了学习。文章主要根据官方文档，对kotlin高阶函数的概念及语法进行了介绍，日后也可作为查阅的资料。 高阶函数，指使用函数作为参数或是返回值的函数 1. 初窥门径 我们先看一下官方提供的范例，来了解一下高阶函数 这个范例使用的是fold函数，它的功能是将规定的初始值与容器中的值通过传入的combine函数，返回构建后的结构，以下是fold函数的源码 12345678910fun &lt;T, R&gt; Collection&lt;T&gt;.fold( initial: R, combine: (acc: R, nextElement: T) -&gt; R): R &#123; var accumulator: R = initial for (element: T in this) &#123; accumulator = combine(accumulator, element) &#125; return accumulator&#125; 从源码中可以看到，combine函数将会使初始值作为累加器和容器中的值进行操作，最后将累加器的值返回，以下是使用的例子： 12345678910111213141516171819202122@Test fun fold_function_test() &#123; val list = ArrayList&lt;String&gt;() list.add(\"b\") list.add(\"c\") list.add(\"d\") val combine1 = &#123; a:String,b:String -&gt; a+b &#125; val result1 = list.fold(\"a\", combine1) assertEquals(\"abcd\",result1) val combine2 = &#123; a:String,b:String-&gt; if(a&lt;b)&#123;a&#125;else&#123;b&#125; &#125; val result2 = list.fold(\"a\",combine2) assertEquals(result2,\"a\") &#125; 需要注意的是,函数作为参数传递时，需要使用函数类型(Function types)进行传递 1.1 函数类型(Function types) 当函数作为参数或是返回值时，需要使用函数类型(Function types)的方式进行定义 函数类型的使用情形 如果想将函数作为参数，或是返回值返回，可以使用下面的方式来申明函数类型 下面情形中的示例代码主要为方便理解，进行的语法展示，不具有实际的使用意义 在函数体中使用如下代码块 lambda表达式 : {a,b -&gt; a+b} 无名函数(an anonymous function) : fun(s:String):Int {return s.toIntOrNull()?:0}123456789101112131415161718192021222324252627@Testfun fold_function_test() &#123; val list = ArrayList&lt;String&gt;() list.add(\"b\") list.add(\"c\") list.add(\"d\") val combine1 = &#123; a:String,b:String -&gt; a+b &#125; val result1 = list.fold(\"a\", combine1) assertEquals(\"abcd\",result1) val combine2 = fun( a:String,b:String):String&#123; if(a&lt;b)&#123; return a &#125;else&#123; return b &#125; &#125; val result2 = list.fold(\"a\",combine2) assertEquals(result2,\"a\")&#125; 引用已经存在的函数 全局、局部成员，扩展函数： ::convertToZero-convertToZero是定义的一个函数,String::toInt 12345678910111213141516171819202122232425262728293031323334//测试辅助类class HigherOrderFunctionHelper() &#123; fun existFunction(method:(String)-&gt;Int):Int&#123; return method(\"10\") &#125;&#125;//单元测试1@Testfun call_exist_function_test_1() &#123; val obj = HigherOrderFunctionHelper() val result = obj.existFunction(String::toInt) assertEquals(10,result)&#125;//单元测试2@Testfun call_exist_function_test_2() &#123; val obj = HigherOrderFunctionHelper() val result = obj.existFunction(::convertToZero) assertEquals(0,result)&#125;//该方法可定义在任意 .kt 文件中fun convertToZero(str:String):Int&#123; return 0&#125; 全局，成员的扩展属性:List&lt;Int&gt;::size 1234567891011121314151617181920212223242526//测试辅助类class HigherOrderFunctionHelper() &#123; fun listPropertyFunction(method:(List&lt;Int&gt;)-&gt;Int):Int&#123; val list = ArrayList&lt;Int&gt;() list.add(0) list.add(1) list.add(2) list.add(3) return method(list) &#125;&#125;//测试方法@Testfun call_exist_function_test_3() &#123; val obj = HigherOrderFunctionHelper() val sizeProperty = List&lt;Int&gt;::size val result = obj.listPropertyFunction(sizeProperty) assertEquals(4,result)&#125; 构造函数作为函数类型传递 ::HigherOrderFunctionHelper 123456789101112131415161718192021222324252627282930313233343536373839404142434445//辅助类class HigherOrderFunctionHelper() &#123; lateinit var param1:Any constructor(param1:Any) : this() &#123; this.param1 = param1 &#125; fun output():Any&#123; if(::param1.isInitialized)&#123; return param1 &#125;else&#123; throw UninitializedPropertyAccessException(\"param1 has not been initialized\") &#125; &#125;&#125;/* 单元测试 * 注意: 类中有两个构造函数的情况，这里申明变量时，指定使用的函数类型 */@Test(expected = UninitializedPropertyAccessException::class)fun class_constructor_as_param_1() &#123; val constructor:()-&gt;HigherOrderFunctionHelper = ::HigherOrderFunctionHelper val helper = constructor() helper.output()&#125;@Testfun class_constructor_as_param_2() &#123; val constructor2:(param:Any)-&gt;HigherOrderFunctionHelper = ::HigherOrderFunctionHelper val helper2 = constructor2(\"test\") val result2 = helper2.output() assertEquals(\"test\",result2)&#125; 一种特殊的情形是，使用某一个对象所具有的方法 helper::output,这里同样要注意函数存在重构的情况下，如何去获取 将函数类型作为接口继承的自定义类 1234567891011121314151617181920212223//自定义类，该类必须实现 invoke方法class FunctionTypeCustomClass : (Int)-&gt;Int&#123; override fun invoke(param1: Int): Int &#123; return param1*10 &#125;&#125;//测试辅助类class HigherOrderFunctionHelper() &#123; fun exeInt2Int(method:(Int)-&gt;Int):Int &#123; return method(10) &#125;&#125;//单元测试@Testfun custom_class_implement_function_type_test() &#123; val obj = HigherOrderFunctionHelper() val result = obj.exeInt2Int(FunctionTypeCustomClass()) assertEquals(100,result)&#125; 调用一个函数类型的情形一个函数类型的值，可以通过f.invoke(x)或者f(x)被调用。 inline函数当需要为高阶函数提供灵活的控制流时，使用 inline函数是十分有益的。可查看官方文档 1.2 Lambda表达式和匿名函数 (Lambda Expression and Anonymous Functions) 下面介绍一些 Lambda表达式以及匿名函数中的基本概念以及使用方法，有些已经在上述的示例中使用了 Lambda表达式语法 Lambda表达式被花括号包裹 -&gt;符号，分割了表达式的参数与逻辑体 逻辑体默认最后一行表示返回值,如果定义了返回结果为 Unit，则返回Unit类型 定义函数类型变量与Lambda表达式进行匹配 val lambda:(Int,Int)-&gt;Int = {a:Int,b:Int -&gt; a+b} 123456789101112131415161718192021@Testfun lambda_test() &#123; val lambda1:(Int,Int)-&gt;Int = &#123;a:Int,b:Int-&gt; val param1 = a*2 val param2 = b*2 param1+param2 &#125; val result1 = lambda1(1, 2) assertEquals(6,result1) val lambda2:(Int,Int)-&gt;Unit = &#123;a:Int,b:Int-&gt; val param1 = a*2 val param2 = b*2 param1+param2 &#125; val result2 = lambda2(1,2) assertThat(Unit,`is`(result2))&#125; lambda 表达式作为最后一个参数 如果是单参数，则可以省略括号 如果是作为最后一个参数时，可以放到括号外面 12345678910111213141516171819fun singleParam(method:(Int)-&gt;Int):Int&#123; return method(2)&#125;fun multiParam(initial:Int,method:(Int)-&gt;Int):Int&#123; return method(initial)&#125;@Testfun lambda_as_last_param_test_1() &#123; val result = singleParam &#123; it * 2 &#125; assertEquals(4,result)&#125;@Testfun lambda_as_last_param_test_2() &#123; val result = multiParam(10) &#123; it * 2 &#125; assertEquals(20,result)&#125; it: 指代Lambda表达式中，单独一个参数的情况ints.filter { it &gt; 0 } // this literal is of type &#39;(it: Int) -&gt; Boolean&#39; 通过lambda表达式返回一个值以下两种方式可以定义lambda表达式的返回体 逻辑体默认最后一行表示返回值 return@函数名 returnValue 使用下划线表示不用的参数如果lambda表达式中，逻辑中有不用的参数，可以使用 _来代替不用的参数 1234567891011121314151617181920212223fun singleParamUnused(initial:Int,method:(String,Int)-&gt;Int):Int&#123; return method(\"\",initial)&#125;fun multiParamUnused(initial:Int,method:(String,Int,String)-&gt;Int):Int&#123; return method(\"\",initial,\"\")&#125;@Testfun lambda_has_unused_variable() &#123; val lambda:(String,Int)-&gt;Int = &#123;_,param -&gt; param*10&#125; val result = singleParamUnused(10, lambda) assertEquals(100,result)&#125;@Testfun lambda_has_unused_variable_2() &#123; val lambda:(String,Int,String)-&gt;Int = &#123;_,param,_ -&gt; param*10&#125; val result = multiParamUnused(10, lambda) assertEquals(100,result)&#125; 解构声明(Destructuring Declarations)相关内容请查看官方文档 匿名函数与Lambda表达式相比，匿名函数可以清晰的定义返回值的类型 1fun(x:Int,y:Int):Int = x + y 有关闭包变量声明在闭包外，这些变量可以在闭包内被捕获，并能够在Lambda表达式中被修改。 12345var sum = 0ints.filter &#123; it &gt; 0 &#125;.forEach &#123; sum += it&#125;print(sum) Function literals with receiver表示方式 A.(B) -&gt; C,可以使用两种方式进行申明： Lambda表达式 val sum: Int.(Int)-&gt; Int = {other -&gt; plus(other)} 匿名函数 val sum = fun Int.(other:Int):Int = this + other 下面例子简单介绍了这种情况: 1234567891011121314151617181920212223242526272829@Testfun function_literal_with_receiver_test1() &#123; val func:String.(Int)-&gt;String = &#123; times -&gt;this.repeat(times) &#125; val str = \"test\" val repeat:(String,Int)-&gt;String = func val result = repeat(str, 3) assertEquals(\"testtesttest\",result)&#125;fun repeat(method:String.(Int)-&gt;String):String&#123; val str = \"hehe!\" return str.method(3)&#125;@Testfun function_literal_with_receiver_test2() &#123; val func:String.(Int)-&gt;String = &#123; times -&gt;this.repeat(times) &#125; val result = repeat(func) assertEquals(\"hehe!hehe!hehe!\",result)&#125; 1.3 小结第一部分根据官方文档，介绍了高阶函数的定义以及各类情况，并提供了简单的例子。但是放在实际项目中该如何使用还需要更进一步的思考。 相关资料Higher-Order Functions and LambdasKotlin——高级篇（二）：高阶函数详解与标准的高阶函数使用","categories":[{"name":"kotlin","slug":"kotlin","permalink":"http://yoursite.com/categories/kotlin/"}],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"http://yoursite.com/tags/kotlin/"}]},{"title":"Mac环境Hexo+Github搭建博客","slug":"Mac环境Hexo-Github搭建博客","date":"2019-10-16T09:55:52.000Z","updated":"2019-12-02T10:02:10.527Z","comments":true,"path":"2019/10/16/Mac环境Hexo-Github搭建博客/","link":"","permalink":"http://yoursite.com/2019/10/16/Mac环境Hexo-Github搭建博客/","excerpt":"文章主要记录了我是如何在Mac环境下，使用 Hexo+Github 搭建博客的…","text":"文章主要记录了我是如何在Mac环境下，使用 Hexo+Github 搭建博客的… 基本使用命令 hexo d -g 生成部署 hexo s -g 生成预览 hexo d 上传网页文件到github hexo new post &quot;article title&quot; 创建博文文件 命令详述 hexo server hexo s 启动本地服务,预览博客 hexo generate hexo g 生成博客网页文件 hexo deploy hexo d 上传网页文件到github hexo new ... hexo new post &quot;article name&quot; hexo new page &quot;page name&quot; hexo clean 搭建过程 安装node.js 安装git，并配置git账号信息 注册github账号并创建项目 注：项目名称必须为 github名称.github.io 在 项目-&gt;Settings-&gt;Source选择为 master branch 安装Hexo,并创建本地博客项目 创建博客维护文件夹，并切换至文件夹下 在控制台中进行操作 npm i hexo-cli -g 进行安装hexo hexo -v验证安装是否成功 hexo init初始化文件夹，注意要在你创建的博客维护文件夹下 npm install 安装必备的组件 hexo g生成静态页面 hexo s 打开本地服务器，http://localhost:4000/查看博客 连接Github与本地博客文件夹 修改博客文件夹根目录下 _config.yml文件 找到deploy进行修改 1234deploy: type: git repository: 项目Clone地址 branch: master 写文章与发布文章 安装扩展 npm i hexo-deployer-git hexo new post &quot;article title&quot; 新建一篇文章 在 博客目录\\source\\_posts 找到新建的文件进行编辑 hexo g 生成静态页面 hexo s 本地预览 hexo d 上传到github 安装node.js Mac下安装方式，参考文章[[Node.js]在mac上安装node.js](https://www.jianshu.com/p/3b30c4c846d1) 扩展1. 使用自己的域名 在 [local_blog_path]/source 新建 CNAME文件,填写自己的域名 在自己申请域名的网站，设置域名解析 2. 博客维护设备转移 多个设备如何同时维护一个博客 如何更换设备重新维护博客 3. 设置主题 Hexo 主题 中挑选主题 我使用的是 MatreialX 演示 主题 关于中查看详细使用方法 MaterialX curl -s https://xaoxuu.com/install | sh -s hexo.sh hexo.sh 使用文档 主题的修改是通过 _config.yml 文件夹下 theme: material-x 进行配置 博客目录/themes下放置各主题方案，配置文件中主题配置要与该目录下文件保持一致 标签 创建博客项目路径/source/blog/tags/index.md 12345---layout: tagindex: truetitle: 所有标签--- 创建的文章时，Front-matter中使用tags: [标签A, 标签B] 文章分类 创建博客项目路径/source/blog/categories/index.md 12345---layout: categoryindex: truetitle: 所有分类--- 创建的文章时，Front-matter中添加categories: [分类A, 分类B] categories 最近文章 npm i -S hexo-related-popular-posts 安装插件 列表中文章摘要 编写的文章中 使用&lt;!-- more --&gt;，该标记之前的信息会作为摘要展示 设置个人信息 参考文章:hexo官方文档超详细Hexo+Github博客搭建小白教程Hexo + GitHub (Coding) Pages 搭建博客Github搭建个人博客GitHub Pages自定义域名Hexo(2)-部署博客及更新博文我的个人博客之旅：从jekyll到hexo","categories":[{"name":"Other","slug":"Other","permalink":"http://yoursite.com/categories/Other/"}],"tags":[{"name":"Other","slug":"Other","permalink":"http://yoursite.com/tags/Other/"}]},{"title":"ndk开发流程","slug":"ndk开发流程","date":"2019-10-12T09:25:30.000Z","updated":"2019-10-16T18:46:42.657Z","comments":true,"path":"2019/10/12/ndk开发流程/","link":"","permalink":"http://yoursite.com/2019/10/12/ndk开发流程/","excerpt":"本文介绍了 Android 如何调用C/C++ 的native代码，比较基础。","text":"本文介绍了 Android 如何调用C/C++ 的native代码，比较基础。 资料NDK开发入门终极教程 Android 调用 C/C++ native代码 配置NDK AndroidStudio SDKManager中下载NDK相关工具 SDK路径下，找到ndk路径 旧版路径为 $SDK_PATH/ndk-bundle 新版路径为 $SDK_PATH/ndk/ndk_version ,新版本可切换不同版本 配置系统环境变量 mac下 /etc/profile PATH = $SDK_PATH/ndk-bundle source /etc/profile Android项目下创建调用native方法的类 声明native函数 加载native函数动态库 实现Android项目中类文件所声明的native方法 方式一 直接编写c/c++文件: 123456789101112131415161718192021222324252627282930//// Created by Yu. on 2019-10-12.//#include &lt;jni.h&gt;#include &lt;stdio.h&gt;#ifdef __cplusplusextern \"C\" &#123;#endifJNIEXPORT jstring JNICALL Java_com_dayizhihui_dayishi_drugstore_feature_test_crash_JNICrashTest_makeCrashABRT(JNIEnv *env, jobject obj)&#123; printf(\"makeCrashABRT() execute..\"); return env-&gt;NewStringUTF(\"makeCrashABRT\");&#125;JNIEXPORT jstring JNICALL Java_com_dayizhihui_dayishi_drugstore_feature_test_crash_JNICrashTest_makeCrashSEGV(JNIEnv *env, jobject obj)&#123; printf(\"makeCrashSEGV() execute..\"); return env-&gt;NewStringUTF(\"makeCrashSEGV\");&#125;#ifdef __cplusplus&#125;#endif 方式二 先根据java源文件生成class文件，再使用class文件生成 .h头文件，利用头文件编写c/c++源文件 javac .../TestJNI.java -d ./bin 编译生成class文件 javah -jni -classpath ./bin -d ./jni com.study.jnilearn.TestJNI 生成头文件 编写源文件 123456789101112131415161718192021//// Created by Yu. on 2019-10-12.//#include \"com_dayizhihui_dayishi_drugstore_feature_test_crash_JNICrashTest.h\"#include &lt;stdio.h&gt;JNIEXPORT jstring JNICALL Java_com_dayizhihui_dayishi_drugstore_feature_test_crash_JNICrashTest_makeCrashABRT(JNIEnv *env, jobject obj)&#123; printf(\"makeCrashABRT() execute..\"); return env-&gt;NewStringUTF(\"makeCrashABRT\");&#125;JNIEXPORT jstring JNICALL Java_com_dayizhihui_dayishi_drugstore_feature_test_crash_JNICrashTest_makeCrashSEGV(JNIEnv *env, jobject obj)&#123; printf(\"makeCrashSEGV() execute..\"); return env-&gt;NewStringUTF(\"makeCrashSEGV\");&#125; 准备生成so库的文件 创建jni文件夹 将第三步编写的源文件放入 在jni文件夹下创建Android.mk 12345678LOCAL_PATH := $(call my-dir)include $(CLEAR_VARS)LOCAL_MODULE := ndk-crash-testLOCAL_SRC_FILES := test.cppinclude $(BUILD_SHARED_LIBRARY) 在jni文件夹下创建Applicaion.mk 12APP_PLATFORM := android-21APP_ABI := armeabi-v7a APP_ABI 表示使用的架构平台, Android可通过Build.SUPPORTED_ABIS查看支持的架构列表，列表从上到下为支持的好的顺序 APP_PLATFORM 表示编译使用的版本, 可在sdk/ndk-bundle/platform下查看版本 切换到jni目录的父目录，执行 ndk-build","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"NDK","slug":"Android/NDK","permalink":"http://yoursite.com/categories/Android/NDK/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"NDK","slug":"NDK","permalink":"http://yoursite.com/tags/NDK/"}]}],"categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"ReadingNote","slug":"Android/ReadingNote","permalink":"http://yoursite.com/categories/Android/ReadingNote/"},{"name":"TDD","slug":"Android/TDD","permalink":"http://yoursite.com/categories/Android/TDD/"},{"name":"kotlin","slug":"kotlin","permalink":"http://yoursite.com/categories/kotlin/"},{"name":"Other","slug":"Other","permalink":"http://yoursite.com/categories/Other/"},{"name":"NDK","slug":"Android/NDK","permalink":"http://yoursite.com/categories/Android/NDK/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"ReadingNote","slug":"ReadingNote","permalink":"http://yoursite.com/tags/ReadingNote/"},{"name":"TDD","slug":"TDD","permalink":"http://yoursite.com/tags/TDD/"},{"name":"kotlin","slug":"kotlin","permalink":"http://yoursite.com/tags/kotlin/"},{"name":"Other","slug":"Other","permalink":"http://yoursite.com/tags/Other/"},{"name":"NDK","slug":"NDK","permalink":"http://yoursite.com/tags/NDK/"}]}