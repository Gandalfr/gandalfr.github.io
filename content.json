{"meta":{"title":"Huasababy","subtitle":null,"description":null,"author":"Huasababy","url":"http://yoursite.com","root":"/"},"pages":[{"title":"所有分类","date":"2019-10-16T17:55:25.531Z","updated":"2019-10-16T17:55:25.331Z","comments":true,"path":"blog/categories/index.html","permalink":"http://yoursite.com/blog/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2019-10-16T17:56:09.800Z","updated":"2019-10-16T17:56:09.800Z","comments":true,"path":"blog/tags/index.html","permalink":"http://yoursite.com/blog/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"kotlin 高阶函数","slug":"kotlin-高阶函数","date":"2019-10-28T11:36:10.000Z","updated":"2019-10-28T11:45:00.121Z","comments":true,"path":"2019/10/28/kotlin-高阶函数/","link":"","permalink":"http://yoursite.com/2019/10/28/kotlin-高阶函数/","excerpt":"在看以kotlin写的开源项目时，对高阶函数的使用抱有很多疑问，因为使用了lambda表达式，各种缩紧的写法，看代码时被高的一头雾水。于是便进行了学习。文章主要根据官方文档，对kotlin高阶函数的概念及语法进行了介绍，日后也可作为查阅的资料。","text":"在看以kotlin写的开源项目时，对高阶函数的使用抱有很多疑问，因为使用了lambda表达式，各种缩紧的写法，看代码时被高的一头雾水。于是便进行了学习。文章主要根据官方文档，对kotlin高阶函数的概念及语法进行了介绍，日后也可作为查阅的资料。 高阶函数，指使用函数作为参数或是返回值的函数 1. 初窥门径 我们先看一下官方提供的范例，来了解一下高阶函数 这个范例使用的是fold函数，它的功能是将规定的初始值与容器中的值通过传入的combine函数，返回构建后的结构，以下是fold函数的源码 12345678910fun &lt;T, R&gt; Collection&lt;T&gt;.fold( initial: R, combine: (acc: R, nextElement: T) -&gt; R): R &#123; var accumulator: R = initial for (element: T in this) &#123; accumulator = combine(accumulator, element) &#125; return accumulator&#125; 从源码中可以看到，combine函数将会使初始值作为累加器和容器中的值进行操作，最后将累加器的值返回，以下是使用的例子： 12345678910111213141516171819202122@Test fun fold_function_test() &#123; val list = ArrayList&lt;String&gt;() list.add(\"b\") list.add(\"c\") list.add(\"d\") val combine1 = &#123; a:String,b:String -&gt; a+b &#125; val result1 = list.fold(\"a\", combine1) assertEquals(\"abcd\",result1) val combine2 = &#123; a:String,b:String-&gt; if(a&lt;b)&#123;a&#125;else&#123;b&#125; &#125; val result2 = list.fold(\"a\",combine2) assertEquals(result2,\"a\") &#125; 需要注意的是,函数作为参数传递时，需要使用函数类型(Function types)进行传递 1.1 函数类型(Function types) 当函数作为参数或是返回值时，需要使用函数类型(Function types)的方式进行定义 函数类型的使用情形 如果想将函数作为参数，或是返回值返回，可以使用下面的方式来申明函数类型 下面情形中的示例代码主要为方便理解，进行的语法展示，不具有实际的使用意义 在函数体中使用如下代码块 lambda表达式 : {a,b -&gt; a+b} 无名函数(an anonymous function) : fun(s:String):Int {return s.toIntOrNull()?:0}123456789101112131415161718192021222324252627@Testfun fold_function_test() &#123; val list = ArrayList&lt;String&gt;() list.add(\"b\") list.add(\"c\") list.add(\"d\") val combine1 = &#123; a:String,b:String -&gt; a+b &#125; val result1 = list.fold(\"a\", combine1) assertEquals(\"abcd\",result1) val combine2 = fun( a:String,b:String):String&#123; if(a&lt;b)&#123; return a &#125;else&#123; return b &#125; &#125; val result2 = list.fold(\"a\",combine2) assertEquals(result2,\"a\")&#125; 引用已经存在的函数 全局、局部成员，扩展函数： ::convertToZero-convertToZero是定义的一个函数,String::toInt 12345678910111213141516171819202122232425262728293031323334//测试辅助类class HigherOrderFunctionHelper() &#123; fun existFunction(method:(String)-&gt;Int):Int&#123; return method(\"10\") &#125;&#125;//单元测试1@Testfun call_exist_function_test_1() &#123; val obj = HigherOrderFunctionHelper() val result = obj.existFunction(String::toInt) assertEquals(10,result)&#125;//单元测试2@Testfun call_exist_function_test_2() &#123; val obj = HigherOrderFunctionHelper() val result = obj.existFunction(::convertToZero) assertEquals(0,result)&#125;//该方法可定义在任意 .kt 文件中fun convertToZero(str:String):Int&#123; return 0&#125; 全局，成员的扩展属性:List&lt;Int&gt;::size 1234567891011121314151617181920212223242526//测试辅助类class HigherOrderFunctionHelper() &#123; fun listPropertyFunction(method:(List&lt;Int&gt;)-&gt;Int):Int&#123; val list = ArrayList&lt;Int&gt;() list.add(0) list.add(1) list.add(2) list.add(3) return method(list) &#125;&#125;//测试方法@Testfun call_exist_function_test_3() &#123; val obj = HigherOrderFunctionHelper() val sizeProperty = List&lt;Int&gt;::size val result = obj.listPropertyFunction(sizeProperty) assertEquals(4,result)&#125; 构造函数作为函数类型传递 ::HigherOrderFunctionHelper 123456789101112131415161718192021222324252627282930313233343536373839404142434445//辅助类class HigherOrderFunctionHelper() &#123; lateinit var param1:Any constructor(param1:Any) : this() &#123; this.param1 = param1 &#125; fun output():Any&#123; if(::param1.isInitialized)&#123; return param1 &#125;else&#123; throw UninitializedPropertyAccessException(\"param1 has not been initialized\") &#125; &#125;&#125;/* 单元测试 * 注意: 类中有两个构造函数的情况，这里申明变量时，指定使用的函数类型 */@Test(expected = UninitializedPropertyAccessException::class)fun class_constructor_as_param_1() &#123; val constructor:()-&gt;HigherOrderFunctionHelper = ::HigherOrderFunctionHelper val helper = constructor() helper.output()&#125;@Testfun class_constructor_as_param_2() &#123; val constructor2:(param:Any)-&gt;HigherOrderFunctionHelper = ::HigherOrderFunctionHelper val helper2 = constructor2(\"test\") val result2 = helper2.output() assertEquals(\"test\",result2)&#125; 一种特殊的情形是，使用某一个对象所具有的方法 helper::output,这里同样要注意函数存在重构的情况下，如何去获取 将函数类型作为接口继承的自定义类 1234567891011121314151617181920212223//自定义类，该类必须实现 invoke方法class FunctionTypeCustomClass : (Int)-&gt;Int&#123; override fun invoke(param1: Int): Int &#123; return param1*10 &#125;&#125;//测试辅助类class HigherOrderFunctionHelper() &#123; fun exeInt2Int(method:(Int)-&gt;Int):Int &#123; return method(10) &#125;&#125;//单元测试@Testfun custom_class_implement_function_type_test() &#123; val obj = HigherOrderFunctionHelper() val result = obj.exeInt2Int(FunctionTypeCustomClass()) assertEquals(100,result)&#125; 调用一个函数类型的情形一个函数类型的值，可以通过f.invoke(x)或者f(x)被调用。 inline函数当需要为高阶函数提供灵活的控制流时，使用 inline函数是十分有益的。可查看官方文档 1.2 Lambda表达式和匿名函数 (Lambda Expression and Anonymous Functions) 下面介绍一些 Lambda表达式以及匿名函数中的基本概念以及使用方法，有些已经在上述的示例中使用了 Lambda表达式语法 Lambda表达式被花括号包裹 -&gt;符号，分割了表达式的参数与逻辑体 逻辑体默认最后一行表示返回值,如果定义了返回结果为 Unit，则返回Unit类型 定义函数类型变量与Lambda表达式进行匹配 val lambda:(Int,Int)-&gt;Int = {a:Int,b:Int -&gt; a+b} 123456789101112131415161718192021@Testfun lambda_test() &#123; val lambda1:(Int,Int)-&gt;Int = &#123;a:Int,b:Int-&gt; val param1 = a*2 val param2 = b*2 param1+param2 &#125; val result1 = lambda1(1, 2) assertEquals(6,result1) val lambda2:(Int,Int)-&gt;Unit = &#123;a:Int,b:Int-&gt; val param1 = a*2 val param2 = b*2 param1+param2 &#125; val result2 = lambda2(1,2) assertThat(Unit,`is`(result2))&#125; lambda 表达式作为最后一个参数 如果是单参数，则可以省略括号 如果是作为最后一个参数时，可以放到括号外面 12345678910111213141516171819fun singleParam(method:(Int)-&gt;Int):Int&#123; return method(2)&#125;fun multiParam(initial:Int,method:(Int)-&gt;Int):Int&#123; return method(initial)&#125;@Testfun lambda_as_last_param_test_1() &#123; val result = singleParam &#123; it * 2 &#125; assertEquals(4,result)&#125;@Testfun lambda_as_last_param_test_2() &#123; val result = multiParam(10) &#123; it * 2 &#125; assertEquals(20,result)&#125; it: 指代Lambda表达式中，单独一个参数的情况ints.filter { it &gt; 0 } // this literal is of type &#39;(it: Int) -&gt; Boolean&#39; 通过lambda表达式返回一个值以下两种方式可以定义lambda表达式的返回体 逻辑体默认最后一行表示返回值 return@函数名 returnValue 使用下划线表示不用的参数如果lambda表达式中，逻辑中有不用的参数，可以使用 _来代替不用的参数 1234567891011121314151617181920212223fun singleParamUnused(initial:Int,method:(String,Int)-&gt;Int):Int&#123; return method(\"\",initial)&#125;fun multiParamUnused(initial:Int,method:(String,Int,String)-&gt;Int):Int&#123; return method(\"\",initial,\"\")&#125;@Testfun lambda_has_unused_variable() &#123; val lambda:(String,Int)-&gt;Int = &#123;_,param -&gt; param*10&#125; val result = singleParamUnused(10, lambda) assertEquals(100,result)&#125;@Testfun lambda_has_unused_variable_2() &#123; val lambda:(String,Int,String)-&gt;Int = &#123;_,param,_ -&gt; param*10&#125; val result = multiParamUnused(10, lambda) assertEquals(100,result)&#125; 解构声明(Destructuring Declarations)相关内容请查看官方文档 匿名函数与Lambda表达式相比，匿名函数可以清晰的定义返回值的类型 1fun(x:Int,y:Int):Int = x + y 有关闭包变量声明在闭包外，这些变量可以在闭包内被捕获，并能够在Lambda表达式中被修改。 12345var sum = 0ints.filter &#123; it &gt; 0 &#125;.forEach &#123; sum += it&#125;print(sum) Function literals with receiver表示方式 A.(B) -&gt; C,可以使用两种方式进行申明： Lambda表达式 val sum: Int.(Int)-&gt; Int = {other -&gt; plus(other)} 匿名函数 val sum = fun Int.(other:Int):Int = this + other 下面例子简单介绍了这种情况: 1234567891011121314151617181920212223242526272829@Testfun function_literal_with_receiver_test1() &#123; val func:String.(Int)-&gt;String = &#123; times -&gt;this.repeat(times) &#125; val str = \"test\" val repeat:(String,Int)-&gt;String = func val result = repeat(str, 3) assertEquals(\"testtesttest\",result)&#125;fun repeat(method:String.(Int)-&gt;String):String&#123; val str = \"hehe!\" return str.method(3)&#125;@Testfun function_literal_with_receiver_test2() &#123; val func:String.(Int)-&gt;String = &#123; times -&gt;this.repeat(times) &#125; val result = repeat(func) assertEquals(\"hehe!hehe!hehe!\",result)&#125; 1.3 小结第一部分根据官方文档，介绍了高阶函数的定义以及各类情况，并提供了简单的例子。但是放在实际项目中该如何使用还需要更进一步的思考。 相关资料Higher-Order Functions and LambdasKotlin——高级篇（二）：高阶函数详解与标准的高阶函数使用","categories":[{"name":"kotlin","slug":"kotlin","permalink":"http://yoursite.com/categories/kotlin/"}],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"http://yoursite.com/tags/kotlin/"}]},{"title":"Mac环境Hexo+Github搭建博客","slug":"Mac环境Hexo-Github搭建博客","date":"2019-10-16T09:55:52.000Z","updated":"2019-10-17T01:20:39.034Z","comments":true,"path":"2019/10/16/Mac环境Hexo-Github搭建博客/","link":"","permalink":"http://yoursite.com/2019/10/16/Mac环境Hexo-Github搭建博客/","excerpt":"文章主要记录了我是如何在Mac环境下，使用 Hexo+Github 搭建博客的…","text":"文章主要记录了我是如何在Mac环境下，使用 Hexo+Github 搭建博客的… 基本使用命令 hexo d -g 生成部署 hexo s -g 生成预览 hexo d 上传网页文件到github hexo new post &quot;article title&quot; 创建博文文件 命令详述 hexo server hexo s 启动本地服务,预览博客 hexo generate hexo g 生成博客网页文件 hexo deploy hexo d 上传网页文件到github hexo new ... hexo new post &quot;article name&quot; hexo new page &quot;page name&quot; hexo clean 搭建过程 安装node.js 安装git，并配置git账号信息 注册github账号并创建项目 注：项目名称必须为 github名称.github.io 在 项目-&gt;Settings-&gt;Source选择为 master branch 安装Hexo,并创建本地博客项目 创建博客维护文件夹，并切换至文件夹下 在控制台中进行操作 npm i hexo-cli -g 进行安装hexo hexo -v验证安装是否成功 hexo init初始化文件夹，注意要在你创建的博客维护文件夹下 npm install 安装必备的组件 hexo g生成静态页面 hexo s 打开本地服务器，http://localhost:4000/查看博客 连接Github与本地博客文件夹 修改博客文件夹根目录下 _config.yml文件 找到deploy进行修改 1234deploy: type: git repository: 项目Clone地址 branch: master 写文章与发布文章 安装扩展 npm i hexo-deployer-git hexo new post &quot;article title&quot; 新建一篇文章 在 博客目录\\source\\_posts 找到新建的文件进行编辑 hexo g 生成静态页面 hexo s 本地预览 hexo d 上传到github 安装node.js Mac下安装方式，参考文章[[Node.js]在mac上安装node.js](https://www.jianshu.com/p/3b30c4c846d1) 扩展1. 使用自己的域名 在 [local_blog_path]/source 新建 CNAME文件,填写自己的域名 在自己申请域名的网站，设置域名解析 2. 博客维护设备转移 多个设备如何同时维护一个博客 如何更换设备重新维护博客 3. 设置主题 Hexo 主题 中挑选主题 我使用的是 MatreialX 演示 主题 关于中查看详细使用方法 MaterialX curl -s https://xaoxuu.com/install | sh -s hexo.sh hexo.sh 使用文档 主题的修改是通过 _config.yml 文件夹下 theme: material-x 进行配置 博客目录/themes下放置各主题方案，配置文件中主题配置要与该目录下文件保持一致 标签 创建博客项目路径/source/blog/tags/index.md 12345---layout: tagindex: truetitle: 所有标签--- 创建的文章时，Front-matter中使用tags: [标签A, 标签B] 文章分类 创建博客项目路径/source/blog/categories/index.md 12345---layout: categoryindex: truetitle: 所有分类--- 创建的文章时，Front-matter中添加categories: [分类A, 分类B] categories 最近文章 npm i -S hexo-related-popular-posts 安装插件 列表中文章摘要 编写的文章中 使用&lt;!-- more --&gt;，该标记之前的信息会作为摘要展示 设置个人信息 参考文章:hexo官方文档超详细Hexo+Github博客搭建小白教程Hexo + GitHub (Coding) Pages 搭建博客Github搭建个人博客GitHub Pages自定义域名Hexo(2)-部署博客及更新博文我的个人博客之旅：从jekyll到hexo","categories":[{"name":"Other","slug":"Other","permalink":"http://yoursite.com/categories/Other/"}],"tags":[{"name":"Other","slug":"Other","permalink":"http://yoursite.com/tags/Other/"}]},{"title":"ndk开发流程","slug":"ndk开发流程","date":"2019-10-12T09:25:30.000Z","updated":"2019-10-16T18:46:42.657Z","comments":true,"path":"2019/10/12/ndk开发流程/","link":"","permalink":"http://yoursite.com/2019/10/12/ndk开发流程/","excerpt":"本文介绍了 Android 如何调用C/C++ 的native代码，比较基础。","text":"本文介绍了 Android 如何调用C/C++ 的native代码，比较基础。 资料NDK开发入门终极教程 Android 调用 C/C++ native代码 配置NDK AndroidStudio SDKManager中下载NDK相关工具 SDK路径下，找到ndk路径 旧版路径为 $SDK_PATH/ndk-bundle 新版路径为 $SDK_PATH/ndk/ndk_version ,新版本可切换不同版本 配置系统环境变量 mac下 /etc/profile PATH = $SDK_PATH/ndk-bundle source /etc/profile Android项目下创建调用native方法的类 声明native函数 加载native函数动态库 实现Android项目中类文件所声明的native方法 方式一 直接编写c/c++文件: 123456789101112131415161718192021222324252627282930//// Created by Yu. on 2019-10-12.//#include &lt;jni.h&gt;#include &lt;stdio.h&gt;#ifdef __cplusplusextern \"C\" &#123;#endifJNIEXPORT jstring JNICALL Java_com_dayizhihui_dayishi_drugstore_feature_test_crash_JNICrashTest_makeCrashABRT(JNIEnv *env, jobject obj)&#123; printf(\"makeCrashABRT() execute..\"); return env-&gt;NewStringUTF(\"makeCrashABRT\");&#125;JNIEXPORT jstring JNICALL Java_com_dayizhihui_dayishi_drugstore_feature_test_crash_JNICrashTest_makeCrashSEGV(JNIEnv *env, jobject obj)&#123; printf(\"makeCrashSEGV() execute..\"); return env-&gt;NewStringUTF(\"makeCrashSEGV\");&#125;#ifdef __cplusplus&#125;#endif 方式二 先根据java源文件生成class文件，再使用class文件生成 .h头文件，利用头文件编写c/c++源文件 javac .../TestJNI.java -d ./bin 编译生成class文件 javah -jni -classpath ./bin -d ./jni com.study.jnilearn.TestJNI 生成头文件 编写源文件 123456789101112131415161718192021//// Created by Yu. on 2019-10-12.//#include \"com_dayizhihui_dayishi_drugstore_feature_test_crash_JNICrashTest.h\"#include &lt;stdio.h&gt;JNIEXPORT jstring JNICALL Java_com_dayizhihui_dayishi_drugstore_feature_test_crash_JNICrashTest_makeCrashABRT(JNIEnv *env, jobject obj)&#123; printf(\"makeCrashABRT() execute..\"); return env-&gt;NewStringUTF(\"makeCrashABRT\");&#125;JNIEXPORT jstring JNICALL Java_com_dayizhihui_dayishi_drugstore_feature_test_crash_JNICrashTest_makeCrashSEGV(JNIEnv *env, jobject obj)&#123; printf(\"makeCrashSEGV() execute..\"); return env-&gt;NewStringUTF(\"makeCrashSEGV\");&#125; 准备生成so库的文件 创建jni文件夹 将第三步编写的源文件放入 在jni文件夹下创建Android.mk 12345678LOCAL_PATH := $(call my-dir)include $(CLEAR_VARS)LOCAL_MODULE := ndk-crash-testLOCAL_SRC_FILES := test.cppinclude $(BUILD_SHARED_LIBRARY) 在jni文件夹下创建Applicaion.mk 12APP_PLATFORM := android-21APP_ABI := armeabi-v7a APP_ABI 表示使用的架构平台, Android可通过Build.SUPPORTED_ABIS查看支持的架构列表，列表从上到下为支持的好的顺序 APP_PLATFORM 表示编译使用的版本, 可在sdk/ndk-bundle/platform下查看版本 切换到jni目录的父目录，执行 ndk-build","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"NDK","slug":"Android/NDK","permalink":"http://yoursite.com/categories/Android/NDK/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"NDK","slug":"NDK","permalink":"http://yoursite.com/tags/NDK/"}]}]}